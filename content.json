{"meta":{"title":"Jachin","subtitle":"Impossible is I’m possible!!!","description":"openwrt  嵌入式  学习总结  思考感悟  知识管理","author":"PN结","url":"https://ygcaicn.github.io"},"pages":[{"title":"","date":"2017-11-12T08:19:55.417Z","updated":"2017-11-12T08:19:55.417Z","comments":true,"path":"index.html","permalink":"https://ygcaicn.github.io/index.html","excerpt":"","text":"","raw":null,"content":null},{"title":"","date":"2018-01-15T10:11:55.510Z","updated":"2018-01-15T10:11:55.510Z","comments":true,"path":"404.html","permalink":"https://ygcaicn.github.io/404.html","excerpt":"","text":"公益404！ 公益404必须友好","raw":null,"content":null},{"title":"","date":"2017-07-26T16:55:17.041Z","updated":"2017-07-26T16:55:17.041Z","comments":true,"path":"dmflz113z8l5eshh4.html","permalink":"https://ygcaicn.github.io/dmflz113z8l5eshh4.html","excerpt":"","text":"dailymotion-domain-verification=dmflz113z8l5eshh4","raw":null,"content":null},{"title":"","date":"2018-01-15T10:09:56.674Z","updated":"2018-01-15T10:09:56.674Z","comments":true,"path":"404/index.html","permalink":"https://ygcaicn.github.io/404/index.html","excerpt":"","text":"公益404必须友好 IE认为小于512字节的404是不友好的！ 公益404必须友好 IE认为小于512字节的404是不友好的！ 公益404必须友好 IE认为小于512字节的404是不友好的！ 公益404必须友好 IE认为小于512字节的404是不友好的！ 公益404必须友好 IE认为小于512字节的404是不友好的！ 公益404必须友好 IE认为小于512字节的404是不友好的！ 公益404必须友好 IE认为小于512字节的404是不友好的！ 公益404必须友好 IE认为小于512字节的404是不友好的！ 公益404必须友好 IE认为小于512字节的404是不友好的！ 公益404必须友好 IE认为小于512字节的404是不友好的！ 公益404必须友好 IE认为小于512字节的404是不友好的！ 公益404必须友好 IE认为小于512字节的404是不友好的！ 公益404必须友好 IE认为小于512字节的404是不友好的！ 公益404必须友好 IE认为小于512字节的404是不友好的！ 公益404必须友好 IE认为小于512字节的404是不友好的！ 公益404必须友好 IE认为小于512字节的404是不友好的！ 公益404必须友好 IE认为小于512字节的404是不友好的！ 公益404必须友好 IE认为小于512字节的404是不友好的！ 公益404必须友好 IE认为小于512字节的404是不友好的！ 公益404必须友好 IE认为小于512字节的404是不友好的！ 公益404必须友好 IE认为小于512字节的404是不友好的！ 公益404必须友好 IE认为小于512字节的404是不友好的！ 公益404必须友好 IE认为小于512字节的404是不友好的！ 公益404必须友好 IE认为小于512字节的404是不友好的！ 公益404必须友好 IE认为小于512字节的404是不友好的！","raw":null,"content":null},{"title":"categories","date":"2017-05-03T11:18:25.785Z","updated":"2017-05-03T11:18:25.785Z","comments":true,"path":"categories/index.html","permalink":"https://ygcaicn.github.io/categories/index.html","excerpt":"","text":"","raw":null,"content":null},{"title":"关于我以及本博客","date":"2016-10-15T06:57:20.000Z","updated":"2018-01-15T10:08:58.141Z","comments":true,"path":"about/index.html","permalink":"https://ygcaicn.github.io/about/index.html","excerpt":"\n现状\n山东大学 控制科学与工程研究生\n中国矿业大学（物理系应用物理学）本科四年级在读生\n恋爱ing\n\n\n","text":"现状 山东大学 控制科学与工程研究生 中国矿业大学（物理系应用物理学）本科四年级在读生 恋爱ing 奖项 幼儿园时多次获得小红花 兴趣 跑步（长跑，马拉松） 收藏癖（各种收藏，金石玉玩，代码软件无所不收） 偶尔会无聊（感觉太没意思，不如研究研究代码） 代码（沉浸在代码中会有安静的感觉） 软件（喜欢尝鲜，欢迎推荐） 嵌入式设备（比如STM32、路由器等） 技能 语言类 C/C++，QT python Keil C（Stm32,51）,Linux c html，css，js 工具类 git MATLAB EDA类Multisim AltiumDesigner 等 Linux 最近ing Qt&amp;PyQt深入学习 智能餐柜项目 硬改路由 科学上网最佳方案 基于STM32+ESP8266的远程温度监控系统 其实现在我是用51 基于WIFI的室内定位技术 博客更新日志 2017/10/24 00:26:00 2017年10月24日: 好好珍惜身边的人，因为你不知道意外和明天哪一个会先到来。——【南茜的早晨】 . . . 2017年10月24日：TCP/IP 详解卷I 2017年05月04日：大三学习任务繁重，很久没update了。 2016年10月24日：C++复习，记录 学习笔记 ，估计要持续更新一段时间了。 2016年10月22日：搭建了manyuser的SS和SS panel，记录了Centos7.2的lamp服务器环境搭建 ，防火墙端口管理 2016年10月15日: 配置Next主题，完善主页，About 2016年10月14日: 闲来无事，偶遇hexo，便擦出了火花，此博客诞生了！ Emial:ygcaicn@gmail.com Facebook: Follow me 微信扫一扫找到我：","raw":null,"content":null},{"title":"gallery","date":"2017-05-04T05:59:38.000Z","updated":"2018-05-17T17:52:55.586Z","comments":true,"path":"gallery/index.html","permalink":"https://ygcaicn.github.io/gallery/index.html","excerpt":"","text":"风景合集","raw":null,"content":null},{"title":"","date":"2018-01-15T11:26:48.623Z","updated":"2018-01-15T11:26:48.623Z","comments":true,"path":"vip/index.html","permalink":"https://ygcaicn.github.io/vip/index.html","excerpt":"","text":"","raw":null,"content":null},{"title":"友情链接","date":"2017-05-04T06:55:31.000Z","updated":"2018-01-15T11:32:49.897Z","comments":false,"path":"link/index.html","permalink":"https://ygcaicn.github.io/link/index.html","excerpt":"","text":"YinZi Hexo vipvideo","raw":null,"content":null},{"title":"Tags","date":"2016-10-14T17:44:41.000Z","updated":"2017-05-04T04:59:46.097Z","comments":true,"path":"tags/index.html","permalink":"https://ygcaicn.github.io/tags/index.html","excerpt":"","text":"","raw":null,"content":null}],"posts":[{"title":"Ubuntu解决QQ难题(Tim)","slug":"Linux-ubuntu-qq","date":"2018-05-19T18:30:42.000Z","updated":"2018-05-19T19:01:52.050Z","comments":true,"path":"Linux/Linux-ubuntu-qq.html","link":"","permalink":"https://ygcaicn.github.io/Linux/Linux-ubuntu-qq.html","excerpt":"使用Ubuntu作为日常生活、工作、学习环境有一点最大的问题就是QQ，博主最近发现一个近乎完美的方案！\n首先说明wine可以解决这个问题，但是我也尝试安装过wine占用两个G空间不说零零散散装了一大堆各种依赖库，而这些库可能只有wine才会用的到，这怎么能符合完美、极简主义呢！！！果断放弃这种方案。本文介绍使用docker安装的方法使用Tim，与系统隔离，不需要自己配置weine，占用707M空间，能记住密码，能发送图片语音红包，能够接收发送文件，能远程，展示了解到的bug只有不能开视频。","text":"使用Ubuntu作为日常生活、工作、学习环境有一点最大的问题就是QQ，博主最近发现一个近乎完美的方案！ 首先说明wine可以解决这个问题，但是我也尝试安装过wine占用两个G空间不说零零散散装了一大堆各种依赖库，而这些库可能只有wine才会用的到，这怎么能符合完美、极简主义呢！！！果断放弃这种方案。本文介绍使用docker安装的方法使用Tim，与系统隔离，不需要自己配置weine，占用707M空间，能记住密码，能发送图片语音红包，能够接收发送文件，能远程，展示了解到的bug只有不能开视频。 Step1.安装安装很简单，一条命令，并且不会零散的安装的导出都是。。 docker push bestwu/qq:office Step.建立启动脚本新建~/opt/qq.sh下如一下内容： 123456789101112131415#/usr/bin/env bash docker run -d \\ --device /dev/snd \\ -v /tmp/.X11-unix:/tmp/.X11-unix \\ -v $HOME/TencentFiles:/TencentFiles \\ -v $HOME:/home/jachin\\ -e DISPLAY=unix$DISPLAY \\ -e XMODIFIERS=@im=fcitx \\ -e QT_IM_MODULE=fcitx \\ -e GTK_IM_MODULE=fcitx \\ -e AUDIO_GID=`getent group audio | cut -d: -f3` \\ -e VIDEO_GID=`getent group video | cut -d: -f3` \\ -e GID=`id -g` \\ -e UID=`id -u` \\ bestwu/qq:office 脚本中的-v选项是指定与qq共享的录，冒号前面的对应主机的实际目录，冒号后面的是对应在Tim中的路径，注意按照自己的实际情况修改。 然后在命令行chmod +x ~/opt/qq.sh 然后新建~/.local/share/applications/tim.desktop 1234567891011[Desktop Entry]Categories=Network;InstantMessaging;Exec=/home/jachin/app/ubuntu/qq.shIcon=timName=Wine QQNoDisplay=falseStartupNotify=trueTerminal=0Type=ApplicationName[en_US]=TIMName[zn_CN]=TIM 下载个Tim的图标命名为tim.png 放置到 ~/.local/share/icons/Papirus/scalable/apps/tim.png然后就能在应用中看到QQ的图标了，到此大功告成！ docker images#查看安装的容器 每天进步一点点!!!!impossible is I’m possible!!!","raw":null,"content":null,"categories":[{"name":"Linux","slug":"Linux","permalink":"https://ygcaicn.github.io/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://ygcaicn.github.io/tags/Linux/"},{"name":"Ubuntu","slug":"Ubuntu","permalink":"https://ygcaicn.github.io/tags/Ubuntu/"}]},{"title":"百度云不限速下载","slug":"Linux-baidudisk-download","date":"2018-05-19T18:09:42.000Z","updated":"2018-05-19T18:22:31.684Z","comments":true,"path":"Linux/Linux-baidudisk-download.html","link":"","permalink":"https://ygcaicn.github.io/Linux/Linux-baidudisk-download.html","excerpt":"百度云下载一直是一个烦人的问题，无奈会员又太贵。。。各种工具又都不靠普\n百度云下载限速的原理是按廉洁数算的，一个链接给几十KB的速度，各种下载工具无非就是采用多线程下载的方法解除限速。总结起来就是先生成下载链接，然后用多线程下载工具进行下载。大家比较熟悉的可能是aria2c,但是它最大的进程数目为16,16*几十Kb也就是几百KB的速度。下面讲解在Ubuntu上的另一个下载工具：axel平台：Ubuntu 18.04 4.15.0-20-generic","text":"百度云下载一直是一个烦人的问题，无奈会员又太贵。。。各种工具又都不靠普 百度云下载限速的原理是按廉洁数算的，一个链接给几十KB的速度，各种下载工具无非就是采用多线程下载的方法解除限速。总结起来就是先生成下载链接，然后用多线程下载工具进行下载。大家比较熟悉的可能是aria2c,但是它最大的进程数目为16,16*几十Kb也就是几百KB的速度。下面讲解在Ubuntu上的另一个下载工具：axel平台：Ubuntu 18.04 4.15.0-20-generic Step1. 获取下载链接获取下载链接的方法有很多一下介绍两种： 从浏览器直接点击下载会生成下载链接，然后复制下载链接待用，取消下载。 安装油猴脚本管理器，然后安装相应的脚本油猴脚本管理器：https://tampermonkey.net/ Chrome打开，点击安装Stable版即可。 脚本：https://greasyfork.org/zh-CN/scripts/by-site/baidu.com脚本网站有很多不限于这一个，进去后搜索使用于baidu.com的脚本，找个比较新点的，得分高的下载即可。然后打开百度云(https://pan.baidu.com)，或则百度云分享链接就能看到下载助手或则是导出链接的字样。 使用Chrome插件类似的插进有很多，这里给出一个BaiduExporterhttps://github.com/acgotaku/BaiduExporter Step2.axel登场安装axel1sudo apt-get update &amp;&amp; sudo apt-get install axel 使用1234567891011121314151617181920212223242526272829303132333435363738Usage: axel [options] url1 [url2] [url...]#指定最大速度（字节/秒）--max-speed=x -s x Specify maximum speed (bytes per second)# 最大链接数--num-connections=x -n x Specify maximum number of connections# 最大重定向次数--max-redirect=x Specify maximum number of redirections# 输出文件指定文件名--output=f -o f Specify local output file# 服务器数目--search[=n] -S[n] Search for mirrors and download from n servers# 强制使用ipv4--ipv4 -4 Use the IPv4 protocol# 强制使用ipv6--ipv6 -6 Use the IPv6 protocol# 指定Http请求的Header--header=x -H x Add HTTP header string# 指定Http请求的user-agent--user-agent=x -U x Set user agent# 不使用代理--no-proxy -N Just don&apos;t use any proxy server# 不验证SSL密钥--insecure -k Don&apos;t verify the SSL certificate# 如果文件已经存在跳过下载--no-clobber -c Skip download if file already exists# 静默模式--quiet -q Leave stdout alone# 详细输出信息--verbose -v More status information# 显示进度条--alternate -a Alternate progress indicator# 帮助--help -h This information# 设置连接超时--timeout=x -T x Set I/O and connection timeout# 查看版本号--version -V Version information Step3.正式下载主要用axel的-n选项进行加速，百度云一般每个链接给几十KB的速度，因此我们链接数目越多下载速度越快！当然还跟你的带宽有关100MB的带宽-n 1000足够慢速下载了。1axel -n 1000 &quot;https://d.pcs.baidu.com/file/32a06e6f67e2567e799300b7f09c4b06?fid=3928561930-250528-591861579041114&amp;dstime=1526751194&amp;rt=sh&amp;sign=FDtAERV-DCb740ccc5511e5e8fedcff06b081203-bkeG852xirZ02HOQHHOi5tBWbzc%3D&amp;expires=8h&amp;chkv=1&amp;chkbd=0&amp;chkpc=&amp;dp-logid=3225304149957301357&amp;dp-callid=0&amp;r=674737288&quot; 注意链接左右的引号不能丢，因为链接内有特殊符号！！！网上有些说的要加ua选项、header选项什么的，2018.05.20亲测不需要加直接就能下载！100M带宽下载12MB/s。 以上就是百度云不限速下载的整个步骤，各种下载工具很多都是利用这个思路实现的。 每天进步一点点!!!!impossible is I’m possible!!!","raw":null,"content":null,"categories":[{"name":"Linux","slug":"Linux","permalink":"https://ygcaicn.github.io/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://ygcaicn.github.io/tags/Linux/"},{"name":"Ubuntu","slug":"Ubuntu","permalink":"https://ygcaicn.github.io/tags/Ubuntu/"}]},{"title":"Live Ubuntu快速布局","slug":"Ubuntu-new","date":"2018-03-22T18:38:42.000Z","updated":"2018-03-22T18:49:30.506Z","comments":true,"path":"Linux/Ubuntu-new.html","link":"","permalink":"https://ygcaicn.github.io/Linux/Ubuntu-new.html","excerpt":"进入live Ubuntu 如何快速布局工作环境呢？\nGo!","text":"进入live Ubuntu 如何快速布局工作环境呢？ Go! 123wget http://blog.cumtpn.com/newu.shchmod +x newu.shsudo ./newu.sh 静候5分钟！ newu.sh12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697#!/usr/bin/env bash# Colorred=&apos;\\033[0;31m&apos;green=&apos;\\033[0;32m&apos;yellow=&apos;\\033[0;33m&apos;plain=&apos;\\033[0m&apos;[[ $EUID -ne 0 ]] &amp;&amp; echo -e &quot;[$&#123;red&#125;Error$&#123;plain&#125;] This script must be run as root!\\n$&#123;green&#125;Maybe you want \\&quot;sudo ./newu.sh\\&quot;$&#123;plain&#125;&quot; &amp;&amp; exit 1echo -e &quot;[$&#123;yellow&#125;root access!$&#123;plain&#125;]&quot;pre_install()&#123; type wget &amp;&gt; /dev/null [[ $? -eq 0 ]] &amp;&amp; apt-get update &amp;&amp; apt-get install -y wget&#125;add_repo()&#123;cat&lt;&lt;EOF &gt; /etc/apt/sources.list.d/google-chrome.listdeb [arch=amd64] https://dl.google.com/linux/chrome/deb/ stable maindeb [arch=amd64] https://repo.fdzh.org/chrome/deb/ stable mainEOFmv /etc/apt/sources.list /etc/apt/sources.list.bakcat&lt;&lt;EOF &gt; /etc/apt/sources.listdeb http://cn.archive.ubuntu.com/ubuntu/ artful main restricted universe multiversedeb http://security.ubuntu.com/ubuntu artful-security main restricted universe multiversedeb http://cn.archive.ubuntu.com/ubuntu/ artful-updates main restricted universe multiverseEOF&#125;add_key()&#123; wget -q -O - https://dl.google.com/linux/linux_signing_key.pub | apt-key add -&#125;# shadowsocksshadowsocks_install()&#123; pushd /tmp wget -q --no-check-certificate https://bootstrap.pypa.io/get-pip.py python get-pip.py rm get-pip.py pip install shadowsocks popd&#125;SwitchyOmega_install()&#123; wget -q --no-check-certificate https://github.com/FelisCatus/SwitchyOmega/releases/download/v2.5.10/SwitchyOmega_Chromium.crx [ -e SwitchyOmega_Chromium.crx ] &amp;&amp; [ -s SwitchyOmega_Chromium.crx ] &amp;&amp; echo -e &quot;$&#123;green&#125;Downloaded SwitchyOmega_Chromium at current directory please open google-chrome install it!$&#123;plain&#125;&quot; if ! [ -e SwitchyOmega_Chromium.crx ] then wget -q --no-check-certificate http://blog.cumtpn.com/SwitchyOmega_Chromium.crx [ -e SwitchyOmega_Chromium.crx ] &amp;&amp; [ -s SwitchyOmega_Chromium.crx ] &amp;&amp; echo -e &quot;$&#123;green&#125;Downloaded SwitchyOmega_Chromium at current directory please open google-chrome install it!$&#123;plain&#125;&quot; fi echo -e &quot;[$&#123;green&#125;Ref$&#123;plain&#125;] https://github.com/FelisCatus/SwitchyOmega/wiki/GFWList&quot; echo -e &quot;[$&#123;green&#125;Con$&#123;plain&#125;] Import profile SwitchyOmega.bak&quot; cat&lt;&lt;EOF &gt; SwitchyOmega.bak&#123;&quot;+GFWed&quot;:&#123;&quot;bypassList&quot;:[&#123;&quot;conditionType&quot;:&quot;BypassCondition&quot;,&quot;pattern&quot;:&quot;&lt;local&gt;&quot;&#125;],&quot;color&quot;:&quot;#99ccee&quot;,&quot;fallbackProxy&quot;:&#123;&quot;host&quot;:&quot;127.0.0.1&quot;,&quot;port&quot;:1080,&quot;scheme&quot;:&quot;socks5&quot;&#125;,&quot;name&quot;:&quot;GFWed&quot;,&quot;profileType&quot;:&quot;FixedProfile&quot;,&quot;revision&quot;:&quot;153abe56d04&quot;&#125;,&quot;+__ruleListOf_自动切换&quot;:&#123;&quot;color&quot;:&quot;#99dd99&quot;,&quot;defaultProfileName&quot;:&quot;direct&quot;,&quot;format&quot;:&quot;AutoProxy&quot;,&quot;matchProfileName&quot;:&quot;GFWed&quot;,&quot;name&quot;:&quot;__ruleListOf_自动切换&quot;,&quot;profileType&quot;:&quot;RuleListProfile&quot;,&quot;revision&quot;:&quot;153abdf798a&quot;,&quot;ruleList&quot;:&quot;&quot;,&quot;sourceUrl&quot;:&quot;https://raw.githubusercontent.com/gfwlist/gfwlist/master/gfwlist.txt&quot;,&quot;lastUpdate&quot;:null&#125;,&quot;+自动切换&quot;:&#123;&quot;color&quot;:&quot;#99dd99&quot;,&quot;defaultProfileName&quot;:&quot;__ruleListOf_自动切换&quot;,&quot;name&quot;:&quot;自动切换&quot;,&quot;profileType&quot;:&quot;SwitchProfile&quot;,&quot;revision&quot;:&quot;153abd3207f&quot;,&quot;rules&quot;:[&#123;&quot;condition&quot;:&#123;&quot;conditionType&quot;:&quot;HostWildcardCondition&quot;,&quot;pattern&quot;:&quot;raw.githubusercontent.com&quot;&#125;,&quot;profileName&quot;:&quot;GFWed&quot;&#125;]&#125;,&quot;-confirmDeletion&quot;:true,&quot;-downloadInterval&quot;:1440,&quot;-enableQuickSwitch&quot;:false,&quot;-monitorWebRequests&quot;:true,&quot;-quickSwitchProfiles&quot;:[],&quot;-refreshOnProfileChange&quot;:true,&quot;-revertProxyChanges&quot;:true,&quot;-showInspectMenu&quot;:true,&quot;-startupProfileName&quot;:&quot;&quot;,&quot;schemaVersion&quot;:2&#125;EOF&#125;install_all()&#123; apt-get update apt-get install -y guake apt-get install -y vim apt-get install -y google-chrome-stable shadowsocks_install echo -e &quot;$&#123;yellow&#125;Please enter shadowsocks server:$&#123;plain&#125;&quot; while [[ -z &quot;$&#123;ss_ip&#125;&quot; ]]; do read -p &quot;shadowsocks server:&quot; ss_ip [ -z $&#123;ss_ip&#125; ] &amp;&amp; ss_ip=45.55.181.140 done echo -e &quot;$&#123;yellow&#125;Please enter shadowsocks password:$&#123;plain&#125;&quot; while [[ -z &quot;$&#123;ss_pwd&#125;&quot; ]]; do read -p &quot;shadowsocks password:&quot; ss_pwd [ -z $&#123;ss_pwd&#125; ] &amp;&amp; ss_pwd=waggywn@10000 done echo -e &quot;$&#123;yellow&#125;Please enter shadowsocks port:$&#123;plain&#125;&quot; read -p &quot;shadowsocks port(Default 6566):&quot; ss_port [[ -z $&#123;ss_port&#125; ]] &amp;&amp; ss_port=6566 echo -e &quot;$&#123;yellow&#125;Please enter shadowsocks method:$&#123;plain&#125;&quot; read -p &quot;shadowsocks method(Default aes-256-cfb):&quot; ss_method [[ -z $&#123;ss_method&#125; ]] &amp;&amp; ss_method=&quot;aes-256-cfb&quot; sslocal -d start -q -s $&#123;ss_ip&#125; -p $&#123;ss_port&#125; -m $&#123;ss_method&#125; -k $&#123;ss_pwd&#125; -l 1080 echo -e &quot;$&#123;green&#125;Start sslocal at 127.0.0.1:1080 $&#123;plain&#125;&quot; SwitchyOmega_install&#125;pre_installadd_repoadd_keyinstall_all 每天进步一点点!!!impossible is I’m possible!!!","raw":null,"content":null,"categories":[{"name":"Linux","slug":"Linux","permalink":"https://ygcaicn.github.io/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://ygcaicn.github.io/tags/Linux/"},{"name":"Ubuntu","slug":"Ubuntu","permalink":"https://ygcaicn.github.io/tags/Ubuntu/"}]},{"title":"Ubuntu17 aria2c安装使用手记","slug":"ubuntu17-aria2c","date":"2018-01-16T04:09:42.000Z","updated":"2018-01-16T09:29:23.526Z","comments":true,"path":"Linux/ubuntu17-aria2c.html","link":"","permalink":"https://ygcaicn.github.io/Linux/ubuntu17-aria2c.html","excerpt":"\naria2 is a utility for downloading files. The supported protocols are HTTP(S), FTP, SFTP, BitTorrent, and Metalink. aria2 can download a file from multiple sources/protocols and tries to utilize your maximum download bandwidth. It supports downloading a file from HTTP(S)/FTP /SFTP and BitTorrent at the same time, while the data downloaded from HTTP(S)/FTP/SFTP is uploaded to the BitTorrent swarm. Using Metalink chunk checksums, aria2 automatically validates chunks of data while downloading a file.\n","text":"aria2 is a utility for downloading files. The supported protocols are HTTP(S), FTP, SFTP, BitTorrent, and Metalink. aria2 can download a file from multiple sources/protocols and tries to utilize your maximum download bandwidth. It supports downloading a file from HTTP(S)/FTP /SFTP and BitTorrent at the same time, while the data downloaded from HTTP(S)/FTP/SFTP is uploaded to the BitTorrent swarm. Using Metalink chunk checksums, aria2 automatically validates chunks of data while downloading a file. 0x01.安装环境： Ubuntu17.10 参考：http://aria2c.com/usage.html 0x02.123456sudo apt-get updatesudo apt-get install aria2sudo mkdir /etc/aria2csudo touch /etc/aria2c/aria2.confsudo touch /etc/aria2c/aria2.sessionchowm -R [your_name] /etc/aria2c ~/.bash_aliases12#ariaalias aria2=&apos;aria2c --conf-path=/etc/aria2c/aria2.conf&apos; 修改完成后 source ~/.bash_aliases Downloads打开命令行输入啊aria2,然后用浏览器打开http://aria2c.com/便可以添加任务！ 0x03. 百度网盘插件https://blog.icehoney.me/posts/2015-01-31-Aria2-download 0x04.每天进步一点点!!!impossible is I’m possible!!!","raw":null,"content":null,"categories":[{"name":"Linux","slug":"Linux","permalink":"https://ygcaicn.github.io/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://ygcaicn.github.io/tags/Linux/"},{"name":"Ubuntu","slug":"Ubuntu","permalink":"https://ygcaicn.github.io/tags/Ubuntu/"}]},{"title":"Linux下python3测试网速","slug":"py3-networkrate","date":"2018-01-15T12:09:42.000Z","updated":"2018-01-15T13:16:44.618Z","comments":true,"path":"python3/py3-networkrate.html","link":"","permalink":"https://ygcaicn.github.io/python3/py3-networkrate.html","excerpt":"python3实现python3学习中写的一个小程序，有时候还挺有用，贴出来做记录！","text":"python3实现python3学习中写的一个小程序，有时候还挺有用，贴出来做记录！ 依赖系统的net-tools工具，也就是ifconfig命令。实现原理利用ifconfig查看网卡发送和接受的数据多少，利用re匹配出需要的数据，利用time模块计时算出1s内发送或者接收数据的多少！ Note 依赖系统的net-tools工具，也就是ifconfig命令。1sudo apt-get install net-tools python3代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#!/usr/bin/env python3import subprocessimport reimport timedef get_total(xdata): s = set([(e[0],e[2]) for e in xdata]) d = dict(s) d.pop('lo') l=list(d.values()) li = [int(i) for i in l] return sum(li)def show(delta): if delta &lt; 1024: n = int(delta) s = 'B' elif delta &lt; 1024*1024: n = delta//1024 s = 'KB' else: n = round(delta/(1024*1024),1) s = 'MB' return str(n)+s+'/S'if __name__ == '__main__': cmd = ['ifconfig'] rx_pat = re.compile(r'\\b(\\w+)\\b:(.+\\s+)+?RX.+?bytes\\s+(\\d+)') tx_pat = re.compile(r'\\b(\\w+)\\b:(.+\\s+)+?TX.+?bytes\\s+(\\d+)') try: while True: out_bytes = subprocess.check_output(cmd) out_str = out_bytes.decode('utf-8') rx = rx_pat.findall(out_str) tx = tx_pat.findall(out_str) rx_data1 = get_total(rx) tx_data1 = get_total(tx) time.sleep(1) out_bytes = subprocess.check_output(cmd) out_str = out_bytes.decode('utf-8') rx = rx_pat.findall(out_str) tx = tx_pat.findall(out_str) rx_data2 = get_total(rx) tx_data2 = get_total(tx) subprocess.call(\"clear\") print(\"↑:\"+show(tx_data2-tx_data1)) print(\"↓:\"+show(rx_data2-rx_data1)) except subprocess.CalledProcessError as e: out_bytes = e.output # Output generated before error code = e.returncode # Return code 其他软件包实现–iftop123sudo apt-get updatesudo apt-get install iftopsudo iftop -n Reference http://os.51cto.com/art/201404/435279.htm 每天进步一点点!!!impossible is I’m possible!!!","raw":null,"content":null,"categories":[{"name":"python3","slug":"python3","permalink":"https://ygcaicn.github.io/categories/python3/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://ygcaicn.github.io/tags/Linux/"},{"name":"Ubuntu","slug":"Ubuntu","permalink":"https://ygcaicn.github.io/tags/Ubuntu/"},{"name":"python3","slug":"python3","permalink":"https://ygcaicn.github.io/tags/python3/"}]},{"title":"build-live-ubuntu --2","slug":"build-live-ubuntu2","date":"2018-01-15T04:09:42.000Z","updated":"2018-01-15T10:04:40.317Z","comments":true,"path":"Linux/build-live-ubuntu2.html","link":"","permalink":"https://ygcaicn.github.io/Linux/build-live-ubuntu2.html","excerpt":"在上次介绍了一些基础的常用软件之后决定进一步探索！在知乎找到了一篇很棒的讨论，链接如下：https://www.zhihu.com/question/19811112通过实践找出了我比较满意的软件。由于本人电脑只有240G的固盘，电脑性能一般，因此对与内存和硬盘都是相当的奢侈，能原配的就不去搞些华丽胡哨的东西，本着能简单绝不复杂，能默认绝不修改的原则去测试一些软件，以及一些脚本，特此记录以备后查！","text":"在上次介绍了一些基础的常用软件之后决定进一步探索！在知乎找到了一篇很棒的讨论，链接如下：https://www.zhihu.com/question/19811112通过实践找出了我比较满意的软件。由于本人电脑只有240G的固盘，电脑性能一般，因此对与内存和硬盘都是相当的奢侈，能原配的就不去搞些华丽胡哨的东西，本着能简单绝不复杂，能默认绝不修改的原则去测试一些软件，以及一些脚本，特此记录以备后查！ No.1 Guake Terminal这个名字有点意思，‘挂科’Terminal。。。功能很简单快速打开Terminal，或许你认为Ctrl+Alt+T（或者自己设置一个快捷键）去开Terminal也是一件很简单的事。没错我以前也是这么认为的，但是遇到了Guake后我改变了看法，特别是需要开多个Terminal的时候（高手都不需要开多个，一个都能全搞定！）系统的Terminal显的不方便，还有就是临时开一个Terminal的时候很可能用完就不去关然后在那积攒了很多。Guake Terminal就是来解决这些问题的！一键弹出（默认F12），失去焦点自动关闭，可以开启多个Tab，可以自定义Appearance。 No.2 ~/.bash_aliases12345678910111213141516171819m_basedir=&apos;/media/jachin/Software&apos;#cdalias pydir=&apos;cd $&#123;m_basedir&#125;/python&apos;alias soft=&apos;cd $&#123;m_basedir&#125;&apos;alias gitdir=&apos;cd $&#123;m_basedir&#125;/Github&apos;#python3 -m venvalias pyvenv=&apos;python3 -m venv&apos;alias pyenv=&apos;pydir &amp;&amp; source ./ENV/bin/activate&apos;#atomalias atoma=&apos;atom -a&apos;#blogalias blogdir=&apos;cd $&#123;m_basedir&#125;/Github/blog-hexo&apos;alias blog=&apos;pushd $&#123;m_basedir&#125;/Github/blog-hexo &amp;&amp; atom -a ./ &amp;&amp; popd&apos;alias blogd=&apos;pushd $&#123;m_basedir&#125;/Github/blog-hexo &amp;&amp; hexo d -g &amp;&amp; popd&apos;alias blogs=&apos;pushd $&#123;m_basedir&#125;/Github/blog-hexo &amp;&amp; hexo s -g &amp;&amp; popd&apos; 配置后我只要F12 blog便用atom打开了我的blog目录，写完之后只要blogd就会执行上传！真的很方便！还可以写很多的快捷命令，搭配GuakeTerminal简直完美！有点像win下Listary。 12345678pydir #进入python的目录pyenv #进入python的目录并进入venvatoma #以append的方式将目录添加到atom中blogdir #进入到blog的目录blog #用atom打开blog目录blogd #上传blogs #本地测试 No.3 Draw.io有很多的模板可以使用，支持存储在本地，Github，google drive等，在线版的viso！ No.4 有道云笔记网易一向很良心，不像某讯。我以前是大象的忠实粉丝，在一次有道云笔记更新以后（支持新的网页版，和markdow的那次更新）我开始慢慢转移到了有道云！markdown，和网页版凭这两点就选择它了！因为我又能少装一个软件了。 每天进步一点点!!!impossible is I’m possible!!!","raw":null,"content":null,"categories":[{"name":"Linux","slug":"Linux","permalink":"https://ygcaicn.github.io/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://ygcaicn.github.io/tags/Linux/"},{"name":"Ubuntu","slug":"Ubuntu","permalink":"https://ygcaicn.github.io/tags/Ubuntu/"}]},{"title":"build-live-ubuntu打造日常使用Ubuntu","slug":"build-live-ubuntu","date":"2017-11-11T04:09:42.000Z","updated":"2018-01-14T19:22:28.687Z","comments":true,"path":"Linux/build-live-ubuntu.html","link":"","permalink":"https://ygcaicn.github.io/Linux/build-live-ubuntu.html","excerpt":"转战Linux后尝试过不少的发行版Mint，Deepin等，换来换去最后还是换成了ubuntu。Ubuntu17.10后回归Gnome桌面，真的越来越棒了！当然选择Linux作为日常live系统最大的问题就是缺少很多日常必须的软件，比如QQ，office，还有一些音乐视频等娱乐软件。本文带你打造一个完美的能够满足日常娱乐与学习的Linux系统！发行版为：Ubuntu17.10","text":"转战Linux后尝试过不少的发行版Mint，Deepin等，换来换去最后还是换成了ubuntu。Ubuntu17.10后回归Gnome桌面，真的越来越棒了！当然选择Linux作为日常live系统最大的问题就是缺少很多日常必须的软件，比如QQ，office，还有一些音乐视频等娱乐软件。本文带你打造一个完美的能够满足日常娱乐与学习的Linux系统！发行版为：Ubuntu17.10 美图几张系统美图： Step1.浏览器Chrome&amp;FireFox浏览器是日常使用的top1。在Ubuntu下也有很多浏览器可以选择，我的搭配为Chrome为主，FireFox为辅。选择Chrome后可以在Chrome的基础上安装很多的Chrome App。 ChromeChrome主页：https://www.google.com/chrome/browser/desktop/index.html#（需要梯子自寻） Chrome安装很简单在上面的链接中下着二进制包安装即可！ FireFoxFirefox主页：https://www.mozilla.org/en-US/firefox/new/ Step2. 编辑器AtomAtom主页：https://atom.io程序员最不可缺少的就是一个好的编辑器。Atom是万能的，开源，有很多的扩展包可以使用。 必须扩展包： Sublime-Style-Column-Celection区块编辑支持 gcc-make-runc文件快速编译运行 markdown-image-paste最棒的插件之一！！！在md文件编辑中，截图以后直接打出文件名然后Ctrl+V将图片存到配置好的目录中，并生成Markdow 图片链接。 uuidgen在粘贴md的图片时总是要起文件名也是一件麻烦的事，还要保证不重复。uuidgen完美解决这个问题！只要快捷键Alt+Commend+G即生成一个uuid。保证不会重复！ atom-python-run快速python运行！ markdown-preview-plus markdown预览，支持latex公式嵌入。 markdown-scroll-sync markdown预览时同步滚动。 Step3.音乐听歌你可以选择网页： http://music.163.com https://youtube.com 但是你有更好的选择，就是Chrome app, Netease Music! chrome app的启动是不依赖与chrome的界面的，因此你完全可以在不启动chrome的情况下直接启动music！ Step4.微信（可作为QQ的替代品）同样chrome app中安装Wechat，其实就是网页版的wechat封装成单独的app可以独立启动！这大概是我对微信刮目相看的唯一理由了。。QQ也是有chrome app的，但是选择wechat而不选择QQ是因为wechat的功能要强大的多！比如支持与好友或者手机互传文件！！！！对的你没看错是文件！！当然照片也是可以的！并且照片是支持截图后Ctrl+v直接粘贴发送的，是不是很方便。然而QQ只能发个表情包里面的表情。。 Step5.office系列office系列的软件有自带的liberate office，效果嘛，，谁用谁知道！….支持国产我们选择wps，完美兼容Mxx公司的几大坨。 wps 主页：http://wps-community.org/download.html Download libpng12-0_1.2.50-2+deb8u2_amd64.deb. If you use a 32 bit system, download the 32 bit deb file.Install the package and then install wps-office. Step6.Foxit ReaderFoxit Reader完美支持Linux： Foxit 主页：https://www.foxitsoftware.com/pdf-reader/ Step7.视频播放器SMplayer","raw":null,"content":null,"categories":[{"name":"Linux","slug":"Linux","permalink":"https://ygcaicn.github.io/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://ygcaicn.github.io/tags/Linux/"},{"name":"Ubuntu","slug":"Ubuntu","permalink":"https://ygcaicn.github.io/tags/Ubuntu/"}]},{"title":"Ubuntu17.10-ChineseInputContexts","slug":"Ubuntu-ChineseInputContexts","date":"2017-11-11T02:32:29.000Z","updated":"2018-01-15T10:26:31.156Z","comments":true,"path":"Linux/Ubuntu-ChineseInputContexts.html","link":"","permalink":"https://ygcaicn.github.io/Linux/Ubuntu-ChineseInputContexts.html","excerpt":"unbuntu下一些常用的软件无法输入中文，这使人很不爽，经过一段时间的努力基本解决了系统中文输入以及常用软件输入中文的问题！环境为Ubuntu17.10 （17.04同样适用）。常用软件包括：\n\nAtom\nWps\nQtCreator\n","text":"unbuntu下一些常用的软件无法输入中文，这使人很不爽，经过一段时间的努力基本解决了系统中文输入以及常用软件输入中文的问题！环境为Ubuntu17.10 （17.04同样适用）。常用软件包括： Atom Wps QtCreator 系统中文输入看图，不多说： 效果图： Qt QtCreator123sudo apt-get install fcitx-libs-qt fcitx-libs-qt5cp /usr/lib/x86_64-linux-gnu/qt5/plugins/platforminputcontexts/libfcitxplatforminputcontextplugin.so ~/qtcreator-4.4.0/lib/Qt/plugins/platforminputcontexts/ 以上操作其实就是安装fcitx-libs-qt和fcitx-libs-qt5的库，然后将动态链接拷贝到qtcreator的插件目录中，至于为什么是这个目录需要你自己去发现，不过我们可以看到在该目录中已经存在ibux的动态链接库，我们只是把fcitx的加进去而已。 当然你也可以不拷贝直接将libfcitxplatforminputcontextplugin.so所在的目录加入到环境变量中应该也是可以的（我没有测试）： 1sudo vim /etx/bash.bashrc 在文件最后添加一行：1export $PATH = $PATH:/usr/lib/x86_64-linux-gnu/qt5/plugins/platforminputcontexts/ 到此重启qtcreator已经可以输入中文了。就是这么简单！效果图： Wpsgoogle搜到的解决办法,(亲测在Ubuntu17.04&amp;17.10中无效) wps文字不能输入中文解决 1$ vim /usr/bin/wps 修改wps启动文件： 123456#!/bin/bashexport XMODIFIERS=&quot;@im=fcitx&quot;export QT_IM_MODULE=&quot;fcitx&quot;gOpt=#gOptExt=-multiplygTemplateExt=(&quot;wpt&quot; &quot;dot&quot; &quot;dotx&quot;) wps writer,表格，ppt对应的启动文件分别为： 123/usr/bin/wps/usr/bin/et/usr/bin/wpp 以上方式在17.04和17.10中亲测无效！！！ 受到qtcreator的启示，同样将libfcitxplatforminputcontextplugin.so动态链接库拷贝到wps的目录中，wps的目录位于： 1/opt/kingsoft/wps-office/office6 可以看到在office6目录下有一个这样的路径： 1/opt/kingsoft/wps-office/office6/qt/plugins/ 和qtcreator的很相似，只是没有platforminputcontexts这个下一级目录，由于强迫症就建立一个这个目录（其实不建也是可以的）把libfcitxplatforminputcontextplugin.so拷贝进来，然后启动wps发现完美解决。 1234567sudo mkdir /opt/kingsoft/wps-office/office6/qt/plugins/platforminputcontextssudo cp /usr/lib/x86_64-linux-gnu/qt5/plugins/platforminputcontexts/libfcitxplatforminputcontextplugin.so /opt/kingsoft/wps-office/office6/qt/plugins/platforminputcontexts/fcitx-autostartwps 效果图： AtomAtom 我没有测试上面的方法，应该也是可以的。我的解决办法是编译安装。 Atom的官方网址：https://atom.io/ binary包安装以后无法输入中文，后来采用编译安装问题的到解决。 编译安装参考：http://flight-manual.atom.io/hacking-atom/sections/hacking-on-atom-core/#platform-linux 效果图： 总结以上通过安装 fcitx-libs-qt fcitx-libs-qt5，然后将动态链接库拷贝到软件的启动目录（或者特定的库目录中）完美解决了Qtcreator，wps，Atom在Ubuntu中的中文输入问题！！Enjoy your Ubuntu!&lt;","raw":null,"content":null,"categories":[{"name":"Linux","slug":"Linux","permalink":"https://ygcaicn.github.io/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://ygcaicn.github.io/tags/Linux/"},{"name":"Qt","slug":"Qt","permalink":"https://ygcaicn.github.io/tags/Qt/"},{"name":"wps","slug":"wps","permalink":"https://ygcaicn.github.io/tags/wps/"}]},{"title":"Qt-doc-struct","slug":"qt-doc-struct","date":"2017-11-09T03:09:40.000Z","updated":"2017-11-09T16:51:30.140Z","comments":true,"path":"Qt/qt-doc-struct.html","link":"","permalink":"https://ygcaicn.github.io/Qt/qt-doc-struct.html","excerpt":"Qt的文档写的非常棒！学习QT最重要的就是学会看官方的文档，了解文档的结构有助于快速的查询文档，解决问题。Qt官方文档的主页为http://doc.qt.io\n进入Qt Reference Documentation后可以看到Qt的文档还分为不同的分类，本文主要是介绍第一个分类：Class Lists\n\nClass Lists中又有不同的索引方式，方便不同情景下查询： \nQt的class文档大致分为3个部分，Type（数据类型），Functions（成员函数），Macros（宏）。每个部分又分为两块，前一块是一个list，简单的列举，后一块为detail，详细信息。每个类的文档都是在同一个html页面上，采用锚点相互跳转，这也是非常棒的一点！","text":"Qt的文档写的非常棒！学习QT最重要的就是学会看官方的文档，了解文档的结构有助于快速的查询文档，解决问题。Qt官方文档的主页为http://doc.qt.io 进入Qt Reference Documentation后可以看到Qt的文档还分为不同的分类，本文主要是介绍第一个分类：Class Lists Class Lists中又有不同的索引方式，方便不同情景下查询： Qt的class文档大致分为3个部分，Type（数据类型），Functions（成员函数），Macros（宏）。每个部分又分为两块，前一块是一个list，简单的列举，后一块为detail，详细信息。每个类的文档都是在同一个html页面上，采用锚点相互跳转，这也是非常棒的一点！ QDir Class 类名 The QDir class provides access to directory structures and their contents. More… 简单介绍功能，可点击查看详细 Header: #include qmake: QT += core 说明header和qmake的包含操作 Public Types 公有的数据类型 12enum Filter &#123; Dirs, AllDirs, Files, Drives, ..., CaseSensitive &#125;flags Filters The Filters type is a typedef for QFlags. It stores an OR combination of Filter values. Public Functions 公有成员函数对象可以访问的函数,编程过程中主要查阅的就是这部分。 Static Public Members 静态成员函数 解决同一个类不同对象之间的数据共享问题。主要作用是用来访问同一个类中的静态数据成员，维护对象之间的数据共享。 访问不依赖于对象。 可以通过对象与类名进行调用，一般习惯与用类名进行访问。 1234567static QDir current()//example：QDir::current()//return a QDir Object of current directory. Macros 宏 Detailed Description该部分介绍QDir的整体概览。又分为小的章节进行介绍 Navigation and Directory OperationsFiles and Directory ContentsThe Current Directory and Other Special Paths Path Manipulation and StringsExamples Member Type Documentation 具体的介绍数据类型 Member Function Documentation 具体的介绍Function，包括static function。每个函数后有See also xxx()非常的方便。 Macro Documentation具体的介绍宏 实例QDir","raw":null,"content":null,"categories":[{"name":"Qt","slug":"Qt","permalink":"https://ygcaicn.github.io/categories/Qt/"}],"tags":[{"name":"Qt","slug":"Qt","permalink":"https://ygcaicn.github.io/tags/Qt/"},{"name":"cpp","slug":"cpp","permalink":"https://ygcaicn.github.io/tags/cpp/"}]},{"title":"TCP/IP","slug":"TCP-IP","date":"2017-10-24T00:32:55.000Z","updated":"2017-10-24T07:37:47.173Z","comments":true,"path":"Linux/TCP-IP.html","link":"","permalink":"https://ygcaicn.github.io/Linux/TCP-IP.html","excerpt":"TCP/IP维基百科：https://zh.wikipedia.org/wiki/TCP/IP%E5%8D%8F%E8%AE%AE%E6%97%8F\n互联网协议族（英语：Internet Protocol Suite，缩写IPS）是一个网络通信模型，以及一整个网络传输协议家族，为互联网的基础通信架构。它常被通称为TCP/IP协议族（英语：TCP/IP Protocol Suite，或TCP/IP Protocols），简称TCP/IP[2]。因为该协议家族的两个核心协议：TCP（传输控制协议）和IP（网际协议），为该家族中最早通过的标准[3]。由于在网络通讯协议普遍采用分层的结构，当多个层次的协议共同工作时，类似计算机科学中的堆栈，因此又被称为TCP/IP协议栈（英语：TCP/IP Protocol Stack）\n整个通信网络的任务，可以划分成不同的功能区块，即所谓的层级（layer）。用于互联网的协议可以比照TCP/IP参考模型进行分类。TCP/IP协议栈起始于第三层协议IP（网际协议）。","text":"TCP/IP维基百科：https://zh.wikipedia.org/wiki/TCP/IP%E5%8D%8F%E8%AE%AE%E6%97%8F 互联网协议族（英语：Internet Protocol Suite，缩写IPS）是一个网络通信模型，以及一整个网络传输协议家族，为互联网的基础通信架构。它常被通称为TCP/IP协议族（英语：TCP/IP Protocol Suite，或TCP/IP Protocols），简称TCP/IP[2]。因为该协议家族的两个核心协议：TCP（传输控制协议）和IP（网际协议），为该家族中最早通过的标准[3]。由于在网络通讯协议普遍采用分层的结构，当多个层次的协议共同工作时，类似计算机科学中的堆栈，因此又被称为TCP/IP协议栈（英语：TCP/IP Protocol Stack） 整个通信网络的任务，可以划分成不同的功能区块，即所谓的层级（layer）。用于互联网的协议可以比照TCP/IP参考模型进行分类。TCP/IP协议栈起始于第三层协议IP（网际协议）。 TCP/IP参考模型是一个抽象的分层模型，这个模型中，所有的TCP/IP系列网络协议都被归类到4个抽象的”层”中。每一抽象层创建在低一层提供的服务上，并且为高一层提供服务。 完成一些特定的任务需要众多的协议协同工作，这些协议分布在参考模型的不同层中的，因此有时称它们为一个协议栈。 TCP/IP参考模型为TCP/IP协议栈订身制作。其中IP协议只关心如何使得数据能够跨越本地网络边界的问题，而不关心如何利用传输媒体，数据如何传输。整个TCP/IP协议栈则负责解决数据如何通过许许多多个点对点通路（一个点对点通路，也称为一”跳”, 1 hop）顺利传输，由此不同的网络成员能够在许多”跳”的基础上创建相互的数据通路。 因特网协议栈中的层 4 . 应用层application layer 例如HTTP、FTP、DNS（如BGP和RIP这样的路由协议，尽管由于各种各样的原因它们分别运行在TCP和UDP上，仍然可以将它们看作网络层的一部分） 3 . 传输层transport layer 例如TCP、UDP、RTP、SCTP（如OSPF这样的路由协议，尽管运行在IP上也可以看作是网络层的一部分） 2 . 网络互连层internet layer 对于TCP/IP来说这是因特网协议（IP）（如ICMP和IGMP这样的必须协议尽管运行在IP上，也仍然可以看作是网络互连层的一部分；ARP不运行在IP上） 1 . 网络接口层link layer 例如以太网、Wi-Fi、MPLS等。 应用层该层包括所有和应用程序协同工作，利用基础网络交换应用程序专用的数据的协议。 应用层是大多数普通与网络相关的程序为了通过网络与其他程序通信所使用的层。这个层的处理过程是应用特有的；数据从网络相关的程序以这种应用内部使用的格式进行传送，然后被编码成标准协议的格式。一些特定的程序被认为运行在这个层上。它们提供服务直接支持用户应用。这些程序和它们对应的协议包括HTTP（万维网服务）、FTP（文件传输）、SMTP（电子邮件）、SSH（安全远程登陆）、DNS（名称&lt;-&gt; IP地址寻找）以及许多其他协议。 一旦从应用程序来的数据被编码成一个标准的应用层协议，它将被传送到IP栈的下一层。 在传输层，应用程序最常用的是TCP或者UDP，并且服务器应用程序经常与一个公开的端口号相联系。服务器应用程序的端口由互联网号码分配局（IANA）正式地分配，但是现今一些新协议的开发者经常选择它们自己的端口号。由于在同一个系统上很少超过少数几个的服务器应用，端口冲突引起的问题很少。应用软件通常也允许用户强制性地指定端口号作为运行参数。连结外部的客户端程序通常使用系统分配的一个随机端口号。监听一个端口并且通过服务器将那个端口发送到应用的另外一个副本以创建对等连结（如IRC上的dcc文件传输）的应用也可以使用一个随机端口，但是应用程序通常允许定义一个特定的端口范围的规范以允许端口能够通过实现网络地址转换（NAT）的路由器映射到内部。 每一个应用层（TCP/IP参考模型的最高层）协议一般都会使用到两个传输层协议之一： 面向连接的TCP传输控制协议和无连接的包传输的UDP用户数据报文协议。 常用的应用层协议有：运行在TCP协议上的协议： ● HTTP（Hypertext Transfer Protocol，超文本传输协议），主要用于普通浏览。 ● HTTPS（Hypertext Transfer Protocol over Secure Socket Layer, or HTTP over SSL，安全超文本传输协议）,HTTP协议的安全版本。 ● FTP（File Transfer Protocol，文件传输协议），由名知义，用于文件传输。 ● POP3（Post Office Protocol, version 3，邮局协议），收邮件用。 ● SMTP（Simple Mail Transfer Protocol，简单邮件传输协议），用来发送电子邮件。 ● TELNET（Teletype over the Network，网络电传），通过一个终端（terminal）登陆到网络。 ● SSH（Secure Shell，用于替代安全性差的TELNET），用于加密安全登陆用。运行在UDP协议上的协议： ● BOOTP（Boot Protocol，启动协议），应用于无盘设备。 ● NTP（Network Time Protocol，网络时间协议），用于网络同步。 ● DHCP（Dynamic Host Configuration Protocol，动态主机配置协议），动态配置IP地址。其他： ● DNS（Domain Name Service，域名服务），用于完成地址查找，邮件转发等工作（运行在TCP和UDP协议上）。 ● ECHO（Echo Protocol，回绕协议），用于查错及测量应答时间（运行在TCP和UDP协议上）。 ● SNMP（Simple Network Management Protocol，简单网络管理协议），用于网络信息的收集和网络管理。 ● ARP（Address Resolution Protocol，地址解析协议），用于动态解析以太网硬件的地址。 传输层传输层的协议，能够解决诸如端到端可靠性（“数据是否已经到达目的地？”）和保证数据按照正确的顺序到达这样的问题。在TCP/IP协议组中，传输协议也包括所给数据应该送给哪个应用程序。 在TCP/IP协议组中技术上位于这个层的动态路由协议通常被认为是网络层的一部分；一个例子就是OSPF（IP协议89）。 TCP（IP协议6）是一个“可靠的”、面向连结的传输机制，它提供一种可靠的字节流保证数据完整、无损并且按顺序到达。TCP尽量连续不断地测试网络的负载并且控制发送数据的速度以避免网络过载。另外，TCP试图将数据按照规定的顺序发送。这是它与UDP不同之处，这在实时数据流或者路由高网络层丢失率应用的时候可能成为一个缺陷。 较新的SCTP也是一个“可靠的”、面向连结的传输机制。它是面向纪录而不是面向字节的，它在一个单独的连结上提供通过多路复用提供的多个子流。它也提供多路自寻址支持，其中连结终端能够被多个IP地址表示（代表多个实体接口），这样的话即使其中一个连接失败了也不中断。它最初是为电话应用开发的（在IP上传输SS7），但是也可以用于其他的应用。 UDP（IP协议号17）是一个无连结的数据报协议。它是一个“尽力传递”（best effort）或者说“不可靠”协议——不是因为它特别不可靠，而是因为它不检查数据包是否已经到达目的地，并且不保证它们按顺序到达。如果一个应用程序需要这些特性，那它必须自行检测和判断，或者使用TCP协议。 UDP的典型性应用是如流媒体（音频和视频等）这样按时到达比可靠性更重要的应用，或者如DNS查找这样的简单查询／响应应用，如果创建可靠的连结所作的额外工作将是不成比例地大。 DCCP目前正由IEFT开发。它提供TCP流动控制语义，但对于用户来说保留UDP的数据报服务模型。 TCP和UDP都用来支持一些高层的应用。任何给定网络地址的应用通过它们的TCP或者UDP端口号区分。根据惯例使一些大众所知的端口与特定的应用相联系。 RTP是为如音频和视频流这样的实时数据设计的数据报协议。RTP是使用UDP包格式作为基础的会话层，然而据说它位于因特网协议栈的传输层。 网络互连层TCP/IP协议族中的网络互连层（internet layer）在OSI模型中叫做网络层（network layer）。正如最初所定义的，网络层解决在一个单一网络上传输数据包的问题。类似的协议有X.25和ARPANET的Host/IMP Protocol。 随着因特网思想的出现，在这个层上添加附加的功能，也就是将数据从源网络传输到目的网络。这就牵涉到在网络组成的网上选择路径将数据包传输，也就是因特网。 在因特网协议组中，IP完成数据从源发送到目的的基本任务。IP能够承载多种不同的高层协议的数据；这些协议使用一个唯一的IP协议号进行标识。ICMP和IGMP分别是1和2。 一些IP承载的协议，如ICMP（用来发送关于IP发送的诊断信息）和IGMP（用来管理多播数据），它们位于IP层之上但是完成网络层的功能，这表明因特网和OSI模型之间的不兼容性。所有的路由协议，如BGP、OSPF、和RIP实际上也是网络层的一部分，尽管它们似乎应该属于更高的协议栈。 网络接口层网络接口层实际上并不是因特网协议组中的一部分，但是它是数据包从一个设备的网络层传输到另外一个设备的网络层的方法。这个过程能够在网卡的软件驱动程序中控制，也可以在韧体或者专用芯片中控制。这将完成如添加报头准备发送、通过实体媒介实际发送这样一些数据链路功能。另一端，链路层将完成数据帧接收、去除报头并且将接收到的包传到网络层。 然而，链路层并不经常这样简单。它也可能是一个虚拟专有网络（VPN）或者隧道，在这里从网络层来的包使用隧道协议和其他（或者同样的）协议组发送而不是发送到实体的接口上。VPN和隧道通常预先建好，并且它们有一些直接发送到实体接口所没有的特殊特点（例如，它可以加密经过它的数据）。由于现在链路“层”是一个完整的网络，这种协议组的递归使用可能引起混淆。但是它是一个实现常见复杂功能的一个优秀方法。（尽管需要注意预防一个已经封装并且经隧道发送下去的数据包进行再次地封装和发送）。","raw":null,"content":null,"categories":[{"name":"Linux","slug":"Linux","permalink":"https://ygcaicn.github.io/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://ygcaicn.github.io/tags/Linux/"},{"name":"TCP/IP","slug":"TCP-IP","permalink":"https://ygcaicn.github.io/tags/TCP-IP/"}]},{"title":"Adblock的一些软件","slug":"adb","date":"2017-10-15T15:02:06.000Z","updated":"2018-01-15T09:55:33.502Z","comments":true,"path":"杂项/adb.html","link":"","permalink":"https://ygcaicn.github.io/杂项/adb.html","excerpt":"推荐列表","text":"推荐列表 1.Adblock Plus （推荐） https://adblockplus.org/zh_CN/ 2.AdBlock https://www.getadblock.com/ 3.adbyby（国产，支持去各大视频站 包括https 的广告，支持openwrt端） https://www.adbyby.com/ 4.adsafe (唯一比较靠谱的国产） http://ad-safe.com/ 5.µBlock https://github.com/gorhill/uBlock 6.Adblock Edge https://addons.mozilla.org/firefox/addon/adblock-edge/ 7.AdGuard http://adguard.com/en/welcome.html 8.AdFender http://www.adfender.com/ 9.Bluhell Firewall https://addons.mozilla.org/en-US/firefox/addon/bluhell-firewall 10.Proxomitron （卡饭有介绍) http://proximodo.sourceforge.net/ 11.poper-blocker http://wzmn.net/poper-blocker 12.Updated Ad Blocker for Firefox https://addons.mozilla.org/en-US/firefox/addon/updated-ad-blocker-for-fire/ 13.javascript-blocker http://javascript-blocker.toggleable.com/ 14.uMatrix https://github.com/gorhill/uMatrix 15.webmailAdBlocker （邮箱广告） http://jasonsavard.com/webmailAdBlocker 16.adblockvideo http://adblockvideo.com/ 17.karma-blocker https://github.com/arantius/karma-blocker 18.奶牛 https://www.admuncher.com/ 附加adb常用屏蔽（update 2017.10.24）1234567891011121314151617baidu.com###content_rightbaidu.com##.cr-offsetbaidu.com##.leftBlockmail.163.com###\\31 508028782489_dvmailrecomPanelContmail.163.com##.gWel-tabs-panel-contmail.163.com##.gWel-tabs-listbaidu.com###s_mancard_mainbaidu.com##.s-top-navdazi.kukuw.com##.gg_close163.com##.col_rtech.163.com###js-ep3rdRank163.com##.gallery-tie-right163.com##.post_content_side163.com##.mt35 mod_bobonews.163.com##.clearfix.bobolistnews.163.com##.mt35.mod_bobo||img1.cache.netease.com/f2e/www/index2014/images/sprite_dw2.png","raw":null,"content":null,"categories":[{"name":"杂项","slug":"杂项","permalink":"https://ygcaicn.github.io/categories/杂项/"}],"tags":[]},{"title":"VIP视频解析+去广告教程","slug":"VIP视频解析-去广告","date":"2017-07-22T00:32:55.000Z","updated":"2018-01-15T10:38:30.729Z","comments":true,"path":"Network/VIP视频解析-去广告.html","link":"","permalink":"https://ygcaicn.github.io/Network/VIP视频解析-去广告.html","excerpt":"VIP视频解析+去广告教程Step1.打开视频网站这里以爱奇艺为例 http://www.iqiyi.com 打开首页看到类似下面的界面：\n","text":"VIP视频解析+去广告教程Step1.打开视频网站这里以爱奇艺为例 http://www.iqiyi.com 打开首页看到类似下面的界面： Step2.找到你要看的视频在视频网站中找到你想要看的视频，看到类似下面的界面： 点击1 指的地方，这里可以看到选择是一个需要VIP才能观看的《河神EP04》，这里无意冒犯出版商版权，多有得罪，提倡大家购买正版观看！ 复制2 指的链接 Step3.打开VIP视频解析+去广告将刚才复制的链接粘贴到输入框中，入下图所示： 1→为输入框，输入在视频网站找到的视频链接 2→为解析接口选择，在无法解析的情况下可以在这里换解析接口，另外支持自定义解析接口。 3→为理解播放按钮，点击即可观看，并且没有广告哟！Step4.分享浏览器地址栏中的链接复制下来发送给好友，好友打开直接可以观看当前的影片！ 支持的网站：","raw":null,"content":null,"categories":[{"name":"Network","slug":"Network","permalink":"https://ygcaicn.github.io/categories/Network/"}],"tags":[{"name":"VIP视频","slug":"VIP视频","permalink":"https://ygcaicn.github.io/tags/VIP视频/"}]},{"title":"关于win10version1703 多引导（grub引导）的问题","slug":"win10-1703-grub","date":"2017-06-01T00:32:55.000Z","updated":"2017-06-01T02:15:58.516Z","comments":true,"path":"Linux/win10-1703-grub.html","link":"","permalink":"https://ygcaicn.github.io/Linux/win10-1703-grub.html","excerpt":"关于win10调包grub引导的过程2017.05.31日中午更新了win10 1703推送的更新，一切由此变的不开心。。。\n往常一直正常的grub引导出问题了，bios启动项中ubuntu这个item还在，不过不幸运的是即使你选择这项引导进行开机进入的依然是windows。这就让人很生气。\n好在我还有移动硬盘的linux，当然你用live盘也是可以的。进去移动硬盘linux后按照上篇文章讲的方法修复了grub。再次进入bios选择ubuntu启动，没什么问题一下就进入了grub熟悉的界面。成功进入了内置硬盘的linuxmint。","text":"关于win10调包grub引导的过程2017.05.31日中午更新了win10 1703推送的更新，一切由此变的不开心。。。 往常一直正常的grub引导出问题了，bios启动项中ubuntu这个item还在，不过不幸运的是即使你选择这项引导进行开机进入的依然是windows。这就让人很生气。 好在我还有移动硬盘的linux，当然你用live盘也是可以的。进去移动硬盘linux后按照上篇文章讲的方法修复了grub。再次进入bios选择ubuntu启动，没什么问题一下就进入了grub熟悉的界面。成功进入了内置硬盘的linuxmint。 本来以为故事到此就结束了呢，骂也骂过了，问题也修复了，万万万万没有想到的是我从win关机之后首先发现了第一个小问题：bios的启动项顺序发生了变化，以往我都是将grub放到第一启动项的，现在变成win是第一项。然后接着来了一个大问题：第二项的ubuntu选项（也就是grub引导程序grubx64.efi）选择从该项启动以后又直接进入了win。到这时候我就已经有了不好的预感。同样从硬盘进入linux看看什么情况，先修复了grub via.一下操作均在live linux下操作 安装修复grub123jachin-Inspiron-5548 ubuntu # sudo grub-install --target x86_64-efi --efi-directory /mnt/esp --boot-directory=/mnt/bootInstalling for x86_64-efi platform.Installation finished. No error reported. grubx64.efi文件jachin-Inspiron-5548 ubuntu # ll -h grubx64.efi -rwx------ 1 root root 118K May 31 09:45 grubx64.efi* 同样修复万以后grub一切正常，重复上次的操作，进入win，关机win，选择grub启动项。和上次结果一样又进了win。。再进入移动硬盘的linux 重启win后grubx64.efi文件jachin-Inspiron-5548 ubuntu # ll -h grubx64.efi -rwx------ 1 root root 74K May 31 09:45 grubx64.efi* 发现了猫腻，万恶的Mxx公司竟然修改了grubx64.efi文件。。。 总结一下就是： win会调包（sda1@efi）/EFI/ubuntu/grubx64.efi文件 win会自动调整启动项的顺序，把自己条boot1 linux下win的分区不能挂载，之前是开着快速启动也可以挂载的，现在不行了。这个关掉快速启动可以解决，没办法果断关掉。 尝试的一些方法修改grubx64.efi的文件名（失败）12345678cp grubx64.efi mgrubx64.efi jachin-Inspiron-5548 ubuntu # ll -htotal 240Kdrwxr-xr-x 2 root root 2.0K May 31 10:18 ./drwxr-xr-x 5 root root 2.0K May 28 00:45 ../-rwxr-xr-x 1 root root 118K May 31 10:09 grubx64.efi*-rwxr-xr-x 1 root root 118K May 31 10:18 mgrubx64.efi* 启动过win之后： 123456jachin-Inspiron-5548 ubuntu # ll -htotal 78Kdrwxr-xr-x 2 root root 2.0K May 31 10:18 ./drwxr-xr-x 5 root root 2.0K May 28 00:45 ../-rwxr-xr-x 1 root root 74K May 31 10:09 grubx64.efi*-rwxr-xr-x 1 root root 0K May 31 10:18 mgrubx64.efi* 可以看到（sda1@efi）/EFI/ubuntu/grubx64.efi文件被调包，（sda1@efi）/EFI/ubuntu/mgrubx64.efi这个更是直接被清空。 修改grubx64.efi所在的文件夹这样可以正常进入grub，但是bios中的启动项要手动添加。并且启动win后添加的启动项被删除了，文件倒是没有被修改，可以通过再次添加进入grub程序。 双Esp分区将以前的esp分区划分成两个esp分区，一个专门用来存放windows的efi程序，另一个专门存放grub的efi程序（grubx64.efi） 先将esp分区中的win引导程序备份出来（不过后来证明我用cp备份的引导并不能正常进入win）拆分分区主要就是用了gdisk工具，格式化为vfat 使用了mkfs.vfat程序，选择一个esp作为linux的引导分区，然后安装grub，还要注意修改内置硬盘系统的/etc/fstab文件中的esp分区挂载的uuid，这个尤其重要，不修改的话也是无法正常进入系统的。ps.这些操作都是在移动硬盘的linux系统中进行的。 这时候重启进入bios中发现自动识别出了sda2也就是我的第二块efi分区中的grub引导，第一块的win引导没有识别。我就手动添加了一下发现启动出了问题，不能正常进入win。没办法逢山开路进winPE，bcdboot修复win引导。这时候需要注意的是你要指定win引导安装在哪个esp分区。到此的话已经win和linux都可以启动了，并且grub引导不会被win调包。 这种解决方法相对完美，但是没有解决win将自身调整为boot1的问题。 需要注意的问题： 拆分分区时第二个esp分区的分区号可能会排到最后，也就是数值最大。这个你可以手动调整分区号，不过开机进入内置硬盘的win后分区号按照扇区的顺序自动调整。 备份win的引导我是没成功，如果又winPE的话可以不备份直接删除格式化，badboot重建win引导。 不要考虑在win下无损调整vfat文件系统的分区。 fstab文件一定要修改的，要不然进不去系统。 参考ESP分区格式化，修复Windows&amp;Linux引导","raw":null,"content":null,"categories":[{"name":"Linux","slug":"Linux","permalink":"https://ygcaicn.github.io/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://ygcaicn.github.io/tags/Linux/"},{"name":"Grub2","slug":"Grub2","permalink":"https://ygcaicn.github.io/tags/Grub2/"},{"name":"Windows","slug":"Windows","permalink":"https://ygcaicn.github.io/tags/Windows/"}]},{"title":"ESP分区格式化，修复Windows&Linux引导","slug":"Esp-grub-uefi-windows","date":"2017-05-14T09:32:55.000Z","updated":"2018-01-15T10:13:42.503Z","comments":true,"path":"Linux/Esp-grub-uefi-windows.html","link":"","permalink":"https://ygcaicn.github.io/Linux/Esp-grub-uefi-windows.html","excerpt":"ESP分区存放的UEFI引导程序，ESP分区被格式化意味着无法进入系统","text":"ESP分区存放的UEFI引导程序，ESP分区被格式化意味着无法进入系统 系统环境Windows10 64Linuxmint 64 双系统 Windows UEFI引导Linux Grub2引导 sda1是我的Esp分区。被我格式化过 sudo mkfs.vfat /dev/sda1 Linux的boot是单独分区的，设备符为：/dev/sda5 修复Linux Grub2进入U盘进入live Linux 方式一从新安装grub2, 挂载esp分区： 12sudo mkdir /mnt/espsudo mount /dev/sda1 /mnt/esp 挂载boot分区： 12sudo mkdir /mnt/bootsudo mount /dev/sda5 /mnt/boot Note: 这里为什么要挂载boot分区？ 因为esp分区 grub-install的–boot-directory选项默认的是镜像安装位置为/boot/grub 12--boot-directory=DIR install GRUB images under the directory DIR/grub instead of the boot/grub directory 为了追求与默认一致，其实也是为了以后更新方便，我们现在要在Live Linux下挂载你的boot分区，然后将Grub的镜像安装到硬盘上的Linux系统的/boot中。其实完全可以将Grub镜像安装到Esp分区中，我们在做U盘Grub时就是将镜像直接放到了Esp分区。 Esp分区只存放UEFI可以认识的efi程序，以及efi程序的字体文件等。 安装grub2: 1sudo grub-install --target x86_64-efi --efi-directory /mnt/esp --boot-directory=/mnt/boot 成功执行结果 12Installing for x86_64-efi platform.Installation finished. No error reported. 错误信息类似于grub-install: error: /usr/lib/grub/x86_64-efi/modinfo.sh doesn’t exist. Please specify –target or –directory. 这样的话，就需要安装grub-pc或grub-efi之后再试。 sudo apt-get install grub-efi -y note: 1--efi-directory=DIR use DIR as the EFI System Partition root 生成grub.cfg 1sudo grub-mkconfig -o /mnt/boot/grub/grub.cfg 这时候我们看一下esp分区中的内容： 1234.└── EFI └── ubuntu └── grubx64.efi 发现里面就只有一个grubx64.efi的文件。这个文件其实就是一个UEFI程序。在UEFI中可以识别这个程序，这个程序又引导CPU进入grub。那么这个程序是怎么找到Grub镜像的位置的呢？（有待查阅，这是不是意味着grub必须从新安装？方法2不可行？） 看看boot分区多了什么东西： 1234567891011121314151617181920grub├── fonts│ └── unicode.pf2├── grub.cfg├── grubenv├── locale│ ├── en_AU.mo│ ├── en_CA.mo│ ├── en_GB.mo│ └── en@quot.mo└── x86_64-efi ├── acpi.mod ├── adler32.mod ├── affs.mod ├── afs.mod ├── ahci.mod : : : └── zfs.mod 重启系统，在UEFI界面应该已经可以看到了grub的启动项。 启动着实进入了grub，也进入了Linux，但是进入的是emergency mode. 这让我百思不得其解，为什么无法进入图形界面？？？Google也没有找到答案，关键是系统没有提示有什么出错的地方。。。 Emergency下df -h发现有些不对的地方：1234567891011jachin@jachin-Inspiron-5548 ~ $ df -hFilesystem Size Used Avail Use% Mounted onudev 3.9G 0 3.9G 0% /devtmpfs 790M 1.5M 789M 1% /run/dev/sda7 19G 14G 4.2G 77% /tmpfs 3.9G 49M 3.9G 2% /dev/shmtmpfs 5.0M 4.0K 5.0M 1% /run/locktmpfs 3.9G 0 3.9G 0% /sys/fs/cgroup/dev/sda5 180M 129M 39M 77% /bootcgmfs 100K 0 100K 0% /run/cgmanager/fstmpfs 790M 36K 790M 1% /run/user/1000 什么情况efi分区没挂载上。 问题解决：最后发现是/etc/fstab出了问题。 123456789101112131415# /etc/fstab: static file system information.## Use &apos;blkid&apos; to print the universally unique identifier for a# device; this may be used with UUID= as a more robust way to name devices# that works even if disks are added and removed. See fstab(5).## &lt;file system&gt; &lt;mount point&gt; &lt;type&gt; &lt;options&gt; &lt;dump&gt; &lt;pass&gt;# / was on /dev/sda7 during installationUUID=29fb7aca-a39d-485e-bcb2-4188ae03b085 / ext4 errors=remount-ro 0 1# /boot was on /dev/sda5 during installationUUID=d5151999-209d-4a90-95f4-e4e70ab02ac7 /boot ext4 defaults 0 2# /boot/efi was on /dev/sda1 during installationUUID=B178-A3FF /boot/efi vfat umask=0077 0 1# swap was on /dev/sda6 during installationUUID=b6f30e1d-84b0-4b23-862c-82cb12773a4f none swap sw 0 0 blkid发现esp分区的UUID竟然与fstab中的不一样。推测是格式化会改变分区的UUID（有待查阅资料）so，把这里的UUID改了之后问题解决。成功进入Linux。 方法二直接拷贝一个grubx64.efi文件,到Esp分区中。 没有测试，不知道行不行。 修复Windows 引导很简单，进入PE 执行1bcdboot c:\\windows /s g: /f UEFI c:为Windows安装的盘符，g：为Esp分区的盘符。Esp分区盘符可以在Diskgens下查看。 /f UEFI选项尽量加上吧，我的不加没有成功哦。 到此位置你的Windows已经可以启动了。 查看一下上面的命令都干了什么事,可以看到esp分区中只有一个目录：EFI 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758EFI├── Boot│ └── bootx64.efi├── Microsoft│ ├── Boot│ │ ├── BCD│ │ ├── BCD.LOG│ │ ├── BCD.LOG1│ │ ├── BCD.LOG2│ │ ├── bg-BG│ │ │ ├── bootmgfw.efi.mui│ │ │ └── bootmgr.efi.mui│ │ ├── bootmgfw.efi│ │ ├── bootmgr.efi│ │ ├── BOOTSTAT.DAT│ │ ├── boot.stl│ │ ├── cs-CZ 语言文件│ │ │ ├── bootmgfw.efi.mui│ │ │ ├── bootmgr.efi.mui│ │ │ └── memtest.efi.mui│ │ ├── en-GB│ │ │ ├── bootmgfw.efi.mui│ │ │ └── bootmgr.efi.mui│ │ ├── en-US│ │ │ ├── bootmgfw.efi.mui│ │ │ ├── bootmgr.efi.mui│ │ │ └── memtest.efi.mui| | :| | :│ │ ├── zh-CN│ │ │ ├── bootmgfw.efi.mui│ │ │ ├── bootmgr.efi.mui│ │ │ └── memtest.efi.mui│ │ ├── Fonts 字体文件│ │ │ ├── chs_boot.ttf│ │ │ :│ │ │ :│ │ │ └── wgl4_boot.ttf│ │ ├── kd_02_10df.dll│ │ :│ │ :│ │ ├── kdstub.dll│ │ ├── memtest.efi│ │ ├── qps-ploc│ │ │ └── memtest.efi.mui│ │ └── Resources│ │ ├── bootres.dll│ │ ├── en-US│ │ │ └── bootres.dll.mui│ │ └── zh-CN│ │ └── bootres.dll.mui│ └── Recovery│ ├── BCD│ ├── BCD.LOG│ ├── BCD.LOG1│ └── BCD.LOG2└── ubuntu └── grubx64.efi windows引导有几类文件：efi文件memtest.efi bootmgr.efi bootmgfw.efi /Boot/bootmgfw.efi字体文件 *.ttf语言文件1234zh-CN├── bootmgfw.efi.mui├── bootmgr.efi.mui└── memtest.efi.mui BCD文件 BCD引导修复这个是最重要的其他的那些文件都可以拷贝，这个不可以。所以前面的命令bcdboot主要任务就是修复这个BCD文件。当然还有其他的修复方式。 Other things现在系统都可以完美启动了，但是还有些不完没就是Grub的引导中没有Windows item。进入Lilnux执行 update-grub2 123456789jachin-Inspiron-5548 boot # update-grub2Generating grub configuration file ...Found linux image: /boot/vmlinuz-4.4.0-77-genericFound initrd image: /boot/initrd.img-4.4.0-77-genericFound linux image: /boot/vmlinuz-4.4.0-75-genericFound initrd image: /boot/initrd.img-4.4.0-75-genericFound Windows Boot Manager on /dev/sda1@/EFI/Microsoft/Boot/bootmgfw.efiAdding boot menu entry for EFI firmware configurationdone okay,现在Grub的menu中已经有Windows选项了，到此完美修复。","raw":null,"content":null,"categories":[{"name":"Linux","slug":"Linux","permalink":"https://ygcaicn.github.io/categories/Linux/"}],"tags":[{"name":"Grub Linux Windows","slug":"Grub-Linux-Windows","permalink":"https://ygcaicn.github.io/tags/Grub-Linux-Windows/"}]},{"title":"mathjax 测试","slug":"mathjax","date":"2017-05-04T13:57:40.000Z","updated":"2018-01-15T10:22:38.408Z","comments":true,"path":"Linux/mathjax.html","link":"","permalink":"https://ygcaicn.github.io/Linux/mathjax.html","excerpt":"$$\\sum_{i=0}^n i^2 = \\frac{(n^2+n)(2n+1)}{6}$$","text":"$$\\sum_{i=0}^n i^2 = \\frac{(n^2+n)(2n+1)}{6}$$","raw":null,"content":null,"categories":[{"name":"Linux","slug":"Linux","permalink":"https://ygcaicn.github.io/categories/Linux/"}],"tags":[]},{"title":"【Machine Learning】机器学习：简明入门指南","slug":"Mechine-Learning","date":"2017-05-04T09:32:55.000Z","updated":"2017-05-04T05:52:22.505Z","comments":true,"path":"Machine-Learning/Mechine-Learning.html","link":"","permalink":"https://ygcaicn.github.io/Machine-Learning/Mechine-Learning.html","excerpt":"\n本文是一篇转载自伯乐在线的译文，英文原文是这里：Machine Learning is Fun! — by Adam Geitgey\n\n在听到人们谈论机器学习的时候，你是不是对它的涵义只有几个模糊的认识呢？你是不是已经厌倦了在和同事交谈时只能一直点头？让我们改变一下吧！\n本指南的读者对象是所有对机器学习有求知欲但却不知道如何开头的朋友。我猜很多人已经读过了“机器学习” ——维基百科词条，倍感挫折，以为没人能给出一个高层次的解释。本文就是你们想要的东西。\n本文目标在于平易近人，这意味着文中有大量的概括。但是谁在乎这些呢？只要能让读者对于ML更感兴趣，任务也就完成了。","text":"本文是一篇转载自伯乐在线的译文，英文原文是这里：Machine Learning is Fun! — by Adam Geitgey 在听到人们谈论机器学习的时候，你是不是对它的涵义只有几个模糊的认识呢？你是不是已经厌倦了在和同事交谈时只能一直点头？让我们改变一下吧！ 本指南的读者对象是所有对机器学习有求知欲但却不知道如何开头的朋友。我猜很多人已经读过了“机器学习” ——维基百科词条，倍感挫折，以为没人能给出一个高层次的解释。本文就是你们想要的东西。 本文目标在于平易近人，这意味着文中有大量的概括。但是谁在乎这些呢？只要能让读者对于ML更感兴趣，任务也就完成了。 何为机器学习？机器学习这个概念认为，对于待解问题，你无需编写任何专门的程序代码，遗传算法（generic algorithms）能够在数据集上为你得出有趣的答案。对于遗传算法，不用编码，而是将数据输入，它将在数据之上建立起它自己的逻辑。 举个例子，有一类算法称为分类算法，它可以将数据划分为不同的组别。一个用来识别手写数字的分类算法，不用修改一行代码，就可以用来将电子邮件分为垃圾邮件和普通邮件。算法没变，但是输入的训练数据变了，因此它得出了不同的分类逻辑。 机器学习算法是个黑盒，可以重用来解决很多不同的分类问题。 “机器学习”是一个涵盖性术语，覆盖了大量类似的遗传算法。 两类机器学习算法你可以认为机器学习算法分为两大类：监督式学习（Supervised Learning）和非监督式学习（Unsupervised Learning）。两者区别很简单，但却非常重要。 监督式学习假设你是一名房产经纪，生意越做越大，因此你雇了一批实习生来帮你。但是问题来了——你可以看一眼房子就知道它到底值多少钱，实习生没有经验，不知道如何估价。 为了帮助你的实习生（也许是为了解放你自己去度个假），你决定写个小软件，可以根据房屋大小、地段以及类似房屋的成交价等因素来评估你所在地区房屋的价值。 你把3个月来城里每笔房屋交易都写了下来，每一单你都记录了一长串的细节——卧室数量、房屋大小、地段等等。但最重要的是，你写下了最终的成交价： 这是我们的“训练数据”: 我们要利用这些训练数据来编写一个程序来估算该地区其他房屋的价值： 这就称为监督式学习。你已经知道每一栋房屋的售价，换句话说，你知道问题的答案，并可以反向找出解题的逻辑。 为了编写软件，你将包含每一套房产的训练数据输入你的机器学习算法。算法尝试找出应该使用何种运算来得出价格数字。 这就像是算术练习题，算式中的运算符号都被擦去了：天哪！一个阴险的学生将老师答案上的算术符号全擦去了。 看了这些题，你能明白这些测验里面是什么样的数学问题吗？你知道，你应该对算式左边的数字“做些什么”以得出算式右边的答案。 在监督式学习中，你是让计算机为你算出数字间的关系。而一旦你知道了解决这类特定问题所需要的数学方法后，你就可以解答同类的其它问题了。 非监督式学习让我们回到开头那个房地产经纪的例子。要是你不知道每栋房子的售价怎么办？即使你所知道的只是房屋的大小、位置等信息，你也可以搞出很酷的花样。这就是所谓的非监督式学习。 即使你不是想去预测未知的数据（如价格），你也可以运用机器学习完成一些有意思的事。 这就有点像有人给你一张纸，上面列出了很多数字，然后对你说:“我不知道这些数字有什么意义，也许你能从中找出规律或是能将它们分类，或是其它什么-祝你好运！” 你该怎么处理这些数据呢？首先，你可以用个算法自动地从数据中划分出不同的细分市场。也许你会发现大学附近的买房者喜欢户型小但卧室多的房子，而郊区的买房者偏好三卧室的大户型。这些信息可以直接帮助你的营销。 你还可以作件很酷的事，自动找出房价的离群数据，即与其它数据迥异的值。这些鹤立鸡群的房产也许是高楼大厦，而你可以将最优秀的推销员集中在这些地区，因为他们的佣金更高。 本文余下部分我们主要讨论监督式学习，但这并不是因为非监督式学习用处不大或是索然无味。实际上，随着算法改良，不用将数据和正确答案联系在一起，因此非监督式学习正变得越来越重要。 老学究请看:还有很多其它种类的机器学习算法。但初学时这样理解不错了。 太酷了，但是评估房价真能被看作“学习”吗？作为人类的一员，你的大脑可以应付绝大多数情况，并且没有任何明确指令也能够学习如何处理这些情况。如果你做房产经纪时间很长，你对于房产的合适定价、它的最佳营销方式以及哪些客户会感兴趣等等都会有一种本能般的“感觉”。强人工智能（Strong AI）研究的目标就是要能够用计算机复制这种能力。 但是目前的机器学习算法还没有那么好——它们只能专注于非常特定的、有限的问题。也许在这种情况下，“学习”更贴切的定义是“在少量范例数据的基础上找出一个等式来解决特定的问题”。 不幸的是，“机器在少量范例数据的基础上找出一个等式来解决特定的问题”这个名字太烂了。所以最后我们用“机器学习”取而代之。 当然，要是你是在50年之后来读这篇文章，那时我们已经得出了强人工智能算法，而本文看起来就像个老古董。未来的人类，你还是别读了，叫你的机器仆人给你做份三明治吧。 让我们写代码吧!前面例子中评估房价的程序，你打算怎么写呢？往下看之前，先思考一下吧。 如果你对机器学习一无所知，很有可能你会尝试写出一些基本规则来评估房价，如下： 123456789101112131415161718192021222324252627def estimate_house_sales_price(num_of_bedrooms, sqft, neighborhood): price = 0 # In my area, the average house costs $200 per sqft price_per_sqft = 200 if neighborhood == \"hipsterton\": # but some areas cost a bit more price_per_sqft = 400 elif neighborhood == \"skid row\": # and some areas cost less price_per_sqft = 100 # start with a base price estimate based on how big the place is price = price_per_sqft * sqft # now adjust our estimate based on the number of bedrooms if num_of_bedrooms == 0: # Studio apartments are cheap price = price — 20000 else: # places with more bedrooms are usually # more valuable price = price + (num_of_bedrooms * 1000) return price 假如你像这样瞎忙几个小时，也许会取得一点成效，但是你的程序永不会完美，而且当价格变化时很难维护。 如果能让计算机找出实现上述函数功能的办法，这样岂不更好？只要返回的房价数字正确，谁会在乎函数具体干了些什么呢？ 1234def estimate_house_sales_price(num_of_bedrooms, sqft, neighborhood): price = &lt;computer, plz do some math for me&gt; return price 考虑这个问题的一种角度是将房价看做一碗美味的汤，而汤中成分就是卧室数、面积和地段。如果你能算出每种成分对最终的价格有多大影响，也许就能得到各种成分混合起来形成最终价格的具体比例。 这样可以将你最初的程序（全是疯狂的if else语句）简化成类似如下的样子： 12345678910111213141516def estimate_house_sales_price(num_of_bedrooms, sqft, neighborhood): price = 0 # a little pinch of this price += num_of_bedrooms * .841231951398213 # and a big pinch of that price += sqft * 1231.1231231 # maybe a handful of this price += neighborhood * 2.3242341421 # and finally, just a little extra salt for good measure price += 201.23432095 return price 请注意那些用粗体标注的神奇数字——.841231951398213, 1231.1231231,2.3242341421, 和201.23432095。它们称为权重。如果我们能找出对每栋房子都适用的完美权重，我们的函数就能预测所有的房价！ 找出最佳权重的一种笨办法如下所示： 步骤1：首先，将每个权重都设为1.0： 12345678910111213141516def estimate_house_sales_price(num_of_bedrooms, sqft, neighborhood): price = 0 # a little pinch of this price += num_of_bedrooms * 1.0 # and a big pinch of that price += sqft * 1.0 # maybe a handful of this price += neighborhood * 1.0 # and finally, just a little extra salt for good measure price += 1.0 return price 步骤2：将每栋房产带入你的函数运算，检验估算值与正确价格的偏离程度： 运用你的程序预测房屋价格。 例如：上表中第一套房产实际成交价为25万美元，你的函数估价为17.8万，这一套房产你就差了7.2万。 再将你的数据集中的每套房产估价偏离值平方后求和。假设数据集中有500套房产交易，估价偏离值平方求和总计为86,123,373美元。这就反映了你的函数现在的“正确”程度。 现在，将总计值除以500，得到每套房产的估价偏离平均值。将这个平均误差值称为你函数的代价。 如果你能调整权重使得这个代价变为0，你的函数就完美了。它意味着，根据输入的数据，你的程序对每一笔房产交易的估价都是分毫不差。而这就是我们的目标——尝试不同的权重值以使代价尽可能的低。 步骤3：不断重复步骤2，尝试所有可能的权重值组合。哪一个组合使得代价最接近于0，它就是你要使用的，你只要找到了这样的组合，问题就得到了解决! 思想扰动时间这太简单了，对吧？想一想刚才你做了些什么。你取得了一些数据，将它们输入至三个通用的简单步骤中，最后你得到了一个可以对你所在区域的房屋进行估价的函数。房价网，要当心咯！但是下面的事实可能会扰乱你的思想： 1.过去40年来，很多领域（如语言学/翻译学）的研究表明，这种通用的“搅动数据汤”（我编造的词）式的学习算法已经胜过了需要利用真人明确规则的方法。机器学习的“笨”办法最终打败了人类专家。 2.你最后写出的函数真是笨，它甚至不知道什么是“面积”和“卧室数”。它知道的只是搅动，改变数字来得到正确的答案。 3.很可能你都不知道为何一组特殊的权重值能起效。所以你只是写出了一个你实际上并不理解却能证明的函数。 4.试想一下，你的程序里没有类似“面积”和“卧室数”这样的参数，而是接受了一组数字。假设每个数字代表了你车顶安装的摄像头捕捉的画面中的一个像素，再将预测的输出不称为“价格”而是叫做“方向盘转动度数”，这样你就得到了一个程序可以自动操纵你的汽车了！ 太疯狂了，对吧？ 步骤3中的“尝试每个数字”怎么回事？好吧，当然你不可能尝试所有可能的权重值来找到效果最好的组合。那可真要花很长时间，因为要尝试的数字可能无穷无尽。 为避免这种情况，数学家们找到了很多聪明的办法（比如Gradient descent算法）来快速找到优秀的权重值，而不需要尝试过多。下面是其中一种： 首先，写出一个简单的等式表示前述步骤2，这是你的代价函数： 接着，让我们将这同一个等式用机器学习的数学术语（现在你可以忽略它们）进行重写： θ表示当前的权重值。 J(θ) 意为“当前权重值对应的代价”。 这个等式表示我们的估价程序在当前权重值下偏离程度的大小。如果将所有赋给卧室数和面积的可能权重值以图形形式显示，我们会得到类似下图的图表： 代价函数的图形像一支碗。纵轴表示代价。 图中蓝色的最低点就是代价最低的地方——即我们的程序偏离最小。最高点意味着偏离最大。所以，如果我们能找到一组权重值带领我们到达图中的最低点，我们就找到了答案！ 因此，我们只需要调整权重值使我们在图上能向着最低点“走下坡路”。如果对于权重的细小调节能一直使我们保持向最低点移动，那么最终我们不用尝试太多权重值就能到达那里。 如果你还记得一点微积分的话，你也许记得如果你对一个函数求导，结果会告诉你函数在任一点的斜率。换句话说，对于图上给定一点，它告诉我们那条路是下坡路。我们可以利用这一点朝底部进发。 所以，如果我们对代价函数关于每一个权重求偏导，那么我们就可以从每一个权重中减去该值。这样可以让我们更加接近山底。一直这样做，最终我们将到达底部，得到权重的最优值。（读不懂？不用担心，接着往下读）。 这种找出最佳权重的办法被称为批量梯度下降，上面是对它的高度概括。如果想搞懂细节，不要害怕，继续深入下去吧。 当你使用机器学习算法库来解决实际问题，所有这些都已经为你准备好了。但明白一些具体细节总是有用的。 还有什么你随便就略过了？上面我描述的三步算法被称为多元线性回归。你估算等式是在求一条能够拟合所有房价数据点的直线。然后，你再根据房价在你的直线上可能出现的位置用这个等式来估算从未见过的房屋的价格。这个想法威力强大，可以用它来解决“实际”问题。 但是，我为你展示的这种方法可能在简单的情况下有效，它不会在所有情况下都有用。原因之一是因为房价不会一直那么简单地跟随一条连续直线。 但是，幸运的是，有很多办法来处理这种情况。对于非线性数据，很多其他类型的机器学习算法可以处理（如神经网络或有核向量机）。还有很多方法运用线性回归更灵活，想到了用更复杂的线条来拟合。在所有的情况中，寻找最优权重值这一基本思路依然适用。 还有，我忽略了过拟合的概念。很容易碰上这样一组权重值，它们对于你原始数据集中的房价都能完美预测，但对于原始数据集之外的任何新房屋都预测不准。这种情况的解决之道也有不少（如正则化以及使用交叉验证数据集）。学会如何处理这一问题对于顺利应用机器学习至关重要。 换言之，基本概念非常简单，要想运用机器学习得到有用的结果还需要一些技巧和经验。但是，这是每个开发者都能学会的技巧。 机器学习法力无边吗？一旦你开始明白机器学习技术很容易应用于解决貌似很困难的问题（如手写识别），你心中会有一种感觉，只要有足够的数据，你就能够用机器学习解决任何问题。只需要将数据输入进去，就能看到计算机变戏法一样找出拟合数据的等式。 但是很重要的一点你要记住，机器学习只能对用你占有的数据实际可解的问题才适用。 例如，如果你建立了一个模型来根据每套房屋内盆栽数量来预测房价，它就永远不会成功。房屋内盆栽数量和房价之间没有任何的关系。所以，无论它怎么去尝试，计算机也推导不出两者之间的关系。 你只能对实际存在的关系建模。 怎样深入学习机器学习我认为，当前机器学习的最大问题是它主要活跃于学术界和商业研究组织中。对于圈外想要有个大体了解而不是想成为专家的人们，简单易懂的学习资料不多。但是这一情况每一天都在改善。 吴恩达教授（Andrew Ng）在Coursera上的机器学习免费课程非常不错。我强烈建议由此入门。任何拥有计算机科学学位、还能记住一点点数学的人应该都能理解。 另外，你还可以下载安装SciKit-Learn，用它来试验成千上万的机器学习算法。它是一个python框架，对于所有的标准算法都有“黑盒”版本。","raw":null,"content":null,"categories":[{"name":"Machine Learning","slug":"Machine-Learning","permalink":"https://ygcaicn.github.io/categories/Machine-Learning/"}],"tags":[{"name":"Machine Learning","slug":"Machine-Learning","permalink":"https://ygcaicn.github.io/tags/Machine-Learning/"}]},{"title":"python基础","slug":"python基础","date":"2017-05-04T07:25:36.000Z","updated":"2018-01-15T13:21:33.926Z","comments":true,"path":"python3/python基础.html","link":"","permalink":"https://ygcaicn.github.io/python3/python基础.html","excerpt":"Strings\nA string is a sequence of values that represent Unicode code points. All the code points in the range U+0000 - U+10FFFF can be represented in a string. Python doesn’t have a char type; instead, every code point in the string is represented as a string object with length 1. The built-in function ord() converts a code point from its string form to an integer in the range 0 - 10FFFF; chr() converts an integer in the range 0 - 10FFFF to the corresponding length 1 string object. str.encode() can be used to convert a str to bytes using the given text encoding, and bytes.decode() can be used to achieve the opposite.\n","text":"Strings A string is a sequence of values that represent Unicode code points. All the code points in the range U+0000 - U+10FFFF can be represented in a string. Python doesn’t have a char type; instead, every code point in the string is represented as a string object with length 1. The built-in function ord() converts a code point from its string form to an integer in the range 0 - 10FFFF; chr() converts an integer in the range 0 - 10FFFF to the corresponding length 1 string object. str.encode() can be used to convert a str to bytes using the given text encoding, and bytes.decode() can be used to achieve the opposite. 12345#str-&gt;bytes str.encode(encoding='UTF-8')#bytes-&gt;str bytes.decode(encoding='UTF-8') document https://docs.python.org/ 123456urllib urllib.error Exception classes raised by urllib.request. urllib.parse Parse URLs into or assemble them from components. urllib.request Extensible library for opening URLs. urllib.response Response classes used by urllib. urllib.robotparser Load a robots.txt file and answer questions about fetchability of other URLs. 标准数据类型 Python3 中有六个标准的数据类型： Number（数字） 123 String（字符串） ‘abc’/“abc” List（列表） [] Tuple（元组） () Sets（集合） ({}) Dictionary（字典）{key:value}* I have a tuple of tuples from a MySQL query like this:123T1 = ((&apos;13&apos;, &apos;17&apos;, &apos;18&apos;, &apos;21&apos;, &apos;32&apos;), (&apos;07&apos;, &apos;11&apos;, &apos;13&apos;, &apos;14&apos;, &apos;28&apos;), (&apos;01&apos;, &apos;05&apos;, &apos;06&apos;, &apos;08&apos;, &apos;15&apos;, &apos;16&apos;)) I’d like to convert all the string elements into integers and put it back nicely to list of lists this time:1T2 = [[13, 17, 18, 21, 32], [7, 11, 13, 14, 28], [1, 5, 6, 8, 15, 16]] I tried to achieve it with eval but didn’t get any decent result yet.1[[int(column) for column in row] for row in T1] 一张图看Python Python网络编程-百度语音接口实例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128# 1 #!/usr/bin/python3 2 3 import urllib 4 import urllib.request 5 import urllib.parse 6 import json 7 import os 8 import sys 9 import hashlib 10 import uuid 11 import base64 12 13 class BaiduRest: 14 def __init__(self,cu_id,api_key,api_secret): 15 self.toKen_url = \"https://openapi.baidu.com/oauth/2.0/token?grant_type=client_credentials&amp;client_id=%s&amp;client_secret=%s&amp;\" 16 self.getVoice_url = \"http://tsn.baidu.com/text2audio\" 17 self.upVoice_url = 'http://vop.baidu.com/server_api' 18 self.cu_id = cu_id 19 self.api_key = api_key 20 self.api_secret = api_secret 21 if not os.path.isdir(\"./cache/\"): 22 os.mkdir(\"./cache/\") 23 os.mkdir(\"./cache/audio\") 24 if not os.path.isdir(\"./cache/audio\"): 25 os.mkdir(\"./cache/audio\") 26 try: 27 file_toKen = open(\"./cache/access_toKen\",'r') 28 self.toKen = file_toKen.read() 29 except FileNotFoundError: 30 self.getToKen(api_key,api_secret) 31 pass 32 33 34 def getToKen(self,api_key,api_secret): 35 self.toKen_url = self.toKen_url % (api_key,api_secret) 36 r_str = urllib.request.urlopen(self.toKen_url).read() 37 r_str = r_str.decode(encoding=\"UTF-8\") 38 r_json = json.loads(r_str) 39 self.toKen = r_json[\"access_token\"] 40 file_toKen = open(\"./cache/access_toKen\",\"w\") 41 file_toKen.write(self.toKen) 42 file_toKen.close() 43 pass 44 45 def getVoice(self,text,filename): 46 #POST 47 params = urllib.parse.urlencode(&#123;'tex':urllib.parse.quote(text),'lan':'zh','cuid':self.cu_id,'ctp':1,'tok':urllib.parse.quote(self.toKen)&#125;) 48 real_url = urllib.request.Request(self.getVoice_url,params.encode(\"utf-8\")) 49 httpResponse = urllib.request.urlopen(real_url) 50 if httpResponse.getheader('Content-type') == 'audio/mp3': 51 #print(\"toKen successful!\") 52 #os.system('date') 53 file_mp3 = open(filename,\"wb+\") 54 file_mp3.write(httpResponse.read()) 55 file_mp3.close() 56 else: 57 self.getToKen(self.api_key,self.api_secret) 39 self.toKen = r_json[\"access_token\"] 40 file_toKen = open(\"./cache/access_toKen\",\"w\") 41 file_toKen.write(self.toKen) 42 file_toKen.close() 43 pass 44 45 def getVoice(self,text,filename): 46 #POST 47 params = urllib.parse.urlencode(&#123;'tex':urllib.parse.quote(text),'lan':'zh','cuid':self.cu_id,'ctp':1,'tok':urllib.parse.quote(self.toKen)&#125;) 48 real_url = urllib.request.Request(self.getVoice_url,params.encode(\"utf-8\")) 49 httpResponse = urllib.request.urlopen(real_url) 50 if httpResponse.getheader('Content-type') == 'audio/mp3': 51 #print(\"toKen successful!\") 52 #os.system('date') 53 file_mp3 = open(filename,\"wb+\") 54 file_mp3.write(httpResponse.read()) 55 file_mp3.close() 56 else: 57 self.getToKen(self.api_key,self.api_secret) 54 file_mp3.write(httpResponse.read()) 54 file_mp3.write(httpResponse.read()) 54 file_mp3.write(httpResponse.read()) 55 file_mp3.close() 56 else: 57 self.getToKen(self.api_key,self.api_secret) 58 self.getVoice(text,filename) 59 60 pass 61 def getText(self, filename): 62 data = &#123;&#125; 63 data['format'] = 'wav' 64 data['rate'] = 16000 65 data['channel'] = 1 6 data['cuid'] = self.cu_id 67 data['token'] = self.toKen 68 wav_fp = open(filename,'rb') 69 voice_data = wav_fp.read() 70 data['len'] = len(voice_data) 71 data['speech'] = base64.b64encode(voice_data).decode('utf-8') 72 post_data = json.dumps(data) 73 reque = urllib.request.Request(self.upVoice_url,post_data.encode(encoding=\"UTF-8\")) 74 r_data = urllib.request.urlopen(reque).read() 75 # 3.处理返回数据 76 r_json = json.loads(r_data.decode(encoding='utf-8')) 77 if 'result' in r_json: 78 return r_json['result'] 79 else: 80 print(r_json) 81 return r_json['err_no'] 82 83 if __name__ == \"__main__\": 84 os.system('date') 85 api_key = \"6PPBMVeF1BIWbXmNuUfEivK3\" 86 api_secret = \"0c5ee6597954b09bee9083624ff3d9a4\" 87 text = sys.argv[1] 88 tmpname_wav = hashlib.md5(text.encode(encoding=\"UTF-8\")).hexdigest() + '.wav' 89 tmpname_wav = './cache/audio/' + tmpname_wav 90 if os.path.isfile(tmpname_wav): 91 print(\"exist!\") 92 os.system(\"omxplayer --loop \\\"\" + tmpname_wav + '\\\"') 93 else: 94 mac = uuid.UUID(int = uuid.getnode()).hex[-12:] 95 mac = \":\".join([mac[e:e+2] for e in range(0,11,2)]) 96 baiduVoice = BaiduRest(mac,api_key,api_secret) 97 baiduVoice.getVoice(text,tmpname_wav) 98 os.system('date') 99 #os.system(\"omxplayer --loop \\\"\" + tmpname_wav + \"\\\"\")100 print(baiduVoice.getText(tmpname_wav))101102 urllib.requestget12345678910111213from urllib import request, parse# Base URL being accessedurl = &apos;http://httpbin.org/get&apos;# Dictionary of query parameters (if any)parms = &#123;&apos;name1&apos; : &apos;value1&apos;,&apos;name2&apos; : &apos;value2&apos;&#125;# Encode the query stringquerystring = parse.urlencode(parms)# Make a GET request and read the responseu = request.urlopen(url+&apos;?&apos; + querystring)resp_bytes = u.read() postpost stand fomer12345678910111213from urllib import request, parse# Base URL being accessedurl = &apos;http://httpbin.org/post&apos;# Dictionary of query parameters (if any)parms = &#123;&apos;name1&apos; : &apos;value1&apos;,&apos;name2&apos; : &apos;value2&apos;&#125;# Encode the query stringquerystring = parse.urlencode(parms)# Make a POST request and read the responseres = request.urlopen(url, querystring.encode(encoding = &apos;utf-8&apos;))html_str = res.read() post json1234567parms = &#123;&apos;name1&apos; : &apos;value1&apos;,&apos;name2&apos; : &apos;value2&apos;&#125;post_data = json.dumps(parms)res = urllib.request.urlopen(url,post_data.encod(encoding=&quot;utf-8&quot;))html_str =res.read() header1234567891011from urllib import request, parse# Extra headersheaders = &#123;&apos;User-agent&apos; : &apos;none/ofyourbusiness&apos;,&apos;Spam&apos; : &apos;Eggs&apos;&#125;req = request.Request(url, querystring.encode(&apos;ascii&apos;), headers=headers)# Make a request and read the responseres = request.urlopen(req)html_str = res.read() header example123456789headers=&#123;&apos;Connection&apos;: &apos;keep-alive&apos;,&apos;Cache-Control&apos;: &apos;max-age=0&apos;,&apos;Upgrade-Insecure-Requests&apos;: 1,&apos;User-Agent&apos;: &apos;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/56.0.2924.87 Safari/537.36&apos;,&apos;Accept&apos;: &apos;text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8&apos;,&apos;Accept-Encoding&apos;: &apos;gzip, deflate, sdch&apos;,&apos;Accept-Language&apos;: &apos;zh-CN,zh;q=0.8,en;q=0.6&apos;&#125; 12Content-Type: application/x-www-form-urlencodedContent-Type: application/json Request123456789GET / HTTP/1.1Host: ip.cnConnection: keep-aliveUpgrade-Insecure-Requests: 1User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/56.0.2924.87 Safari/537.36Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8Accept-Encoding: gzip, deflate, sdchAccept-Language: zh-CN,zh;q=0.8,en;q=0.6Cookie: UM_distinctid=15ae0d3744b437-0ebcb4eece40e4-57e1b3c-100200-15ae0d3744c42b; CNZZDATA123770=cnzz_eid%3D646344926-1484393339-%26ntime%3D1489830206 Responseencoding:gzip when unzip the body,we can see: 1234567891011121314151617181920212223242526272829303132HTTP/1.1 200 OKServer: nginx/1.8.0Date: Sat, 18 Mar 2017 10:54:28 GMTContent-Type: text/html; charset=UTF-8Connection: keep-aliveVary: Accept-EncodingX-Powered-By: PHP/5.6.30-1~dotdeb+7.1Content-Length: 3189&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;&gt;&lt;link href=&quot;http://s.ip-cdn.com&quot; rel=&quot;dns-prefetch&quot; /&gt;&lt;title&gt;IP.cn - IP 地址查询 | 地理位置 | 手机归属地&lt;/title&gt;&lt;meta name=&quot;robots&quot; content=&quot;all&quot; /&gt;&lt;meta name=&quot;Keywords&quot; content=&quot;ip,ip查询,手机ip,本机ip,外网ip,ip地址查询,手机号,归属地&quot;&gt;&lt;meta name=&quot;Description&quot; content=&quot;专业本机 IP 地址查询、手机 IP 地址、地理位置查询、IP 数据库、手机号归属地查询、电话号码黄页查询，可查广告、骚扰、快递、银行、保险、房地产、中介电话。&quot;&gt;&lt;link href=&apos;http://s.ip-cdn.com/css/bootstrap.min.css&apos; rel=&apos;stylesheet&apos; type=&apos;text/css&apos;&gt;&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, minimum-scale=0.5&quot;&gt;&lt;meta name=&quot;format-detection&quot; content=&quot;telephone=no&quot;&gt;&lt;!--[if lt IE 8]&gt;&lt;script src=&quot;http://s.ip-cdn.com/js/ie8.js&quot;&gt;&lt;/script&gt;&lt;![endif]--&gt;&lt;link href=&apos;http://s.ip-cdn.com/css/main.css&apos; rel=&apos;stylesheet&apos; type=&apos;text/css&apos;&gt;&lt;/head&gt;&lt;body onLoad=&quot;document.fs.ip.focus()&quot;&gt;...&lt;/body&gt;&lt;/html&gt; 参考入门Python3教程 进阶技巧python3-cookbookreadthedocspython-requests httbin.org","raw":null,"content":null,"categories":[{"name":"python3","slug":"python3","permalink":"https://ygcaicn.github.io/categories/python3/"}],"tags":[{"name":"python","slug":"python","permalink":"https://ygcaicn.github.io/tags/python/"}]},{"title":"GPT(GUID partition table)","slug":"GPT","date":"2017-05-04T05:04:44.000Z","updated":"2018-05-17T17:09:56.797Z","comments":true,"path":"Linux/GPT.html","link":"","permalink":"https://ygcaicn.github.io/Linux/GPT.html","excerpt":"GPT 磁盘分区表：\nLBA – Logical Block Adress\nsize of  LBA :512bytes(0.5KB)\nLBA0~LBA33: GUID partition table(GPT)\nLBA(end-33)~LBA(end): Backup GPT","text":"GPT 磁盘分区表： LBA – Logical Block Adress size of LBA :512bytes(0.5KB) LBA0~LBA33: GUID partition table(GPT) LBA(end-33)~LBA(end): Backup GPT 12345678910Disk /dev/sdb: 33021952 sectors, 15.7 GiBLogical sector size: 512 bytesDisk identifier (GUID): 2A7B560E-11D2-48FE-9A16-A54069811BF4Partition table holds up to 128 entriesFirst usable sector is 34, last usable sector is 33021918Partitions will be aligned on 2048-sector boundariesTotal free space is 2014 sectors (1007.0 KiB)Number Start (sector) End (sector) Size Code Name 1 2048 33021918 15.7 GiB 8300 Linux filesystem gdiskCommand1234567891011121314151617Command (? for help): ?b back up GPT data to a filec change a partition&apos;s named delete a partitioni show detailed information on a partitionl list known partition typesn add a new partitiono create a new empty GUID partition table (GPT)p print the partition tableq quit without saving changesr recovery and transformation options (experts only)s sort partitionst change a partition&apos;s type codev verify diskw write table to disk and exitx extra functionality (experts only)? print this menu Recovery/transformation12345678910111213141516171819Recovery/transformation command (? for help): ?b use backup GPT header (rebuilding main)c load backup partition table from disk (rebuilding main)d use main GPT header (rebuilding backup)e load main partition table from disk (rebuilding backup)f load MBR and build fresh GPT from itg convert GPT into MBR and exith make hybrid MBRi show detailed information on a partitionl load partition data from a backup filem return to main menuo print protective MBR datap print the partition tableq quit without saving changest transform BSD disklabel partitionv verify diskw write table to disk and exitx extra functionality (experts only)? print this menu Expert12345678910111213141516171819202122Expert command (? for help): ?a set attributesc change partition GUIDd display the sector alignment valuee relocate backup data structures to the end of the diskg change disk GUIDh recompute CHS values in protective/hybrid MBRi show detailed information on a partitionl set the sector alignment valuem return to main menun create a new protective MBRo print protective MBR datap print the partition tableq quit without saving changesr recovery and transformation options (experts only)s resize partition tablet transpose two partition table entriesu replicate partition table on new devicev verify diskw write table to disk and exitz zap (destroy) GPT data structures and exit? print this menu partition’s type code12345678910111213141516171819202122232425262728290700 Microsoft basic data 0c01 Microsoft reserved 2700 Windows RE 3000 ONIE boot 3001 ONIE config 3900 Plan 9 4100 PowerPC PReP boot 4200 Windows LDM data 4201 Windows LDM metadata4202 Windows Storage Spac 7501 IBM GPFS 7f00 ChromeOS kernel 7f01 ChromeOS root 7f02 ChromeOS reserved 8200 Linux swap 8300 Linux filesystem 8301 Linux reserved 8302 Linux /home 8303 Linux x86 root (/) 8304 Linux x86-64 root (/ 8305 Linux ARM64 root (/)8306 Linux /srv 8307 Linux ARM32 root (/) 8400 Intel Rapid Start 8e00 Linux LVM a500 FreeBSD disklabel a501 FreeBSD boot a502 FreeBSD swap a503 FreeBSD UFS a504 FreeBSD ZFS a505 FreeBSD Vinum/RAID a580 Midnight BSD data a581 Midnight BSD boot a582 Midnight BSD swap a583 Midnight BSD UFS a584 Midnight BSD ZFS a585 Midnight BSD Vinum a600 OpenBSD disklabel a800 Apple UFS a901 NetBSD swap a902 NetBSD FFS a903 NetBSD LFS a904 NetBSD concatenated a905 NetBSD encrypted a906 NetBSD RAID ab00 Recovery HD af00 Apple HFS/HFS+ af01 Apple RAID af02 Apple RAID offline af03 Apple label af04 AppleTV recovery af05 Apple Core Storage bc00 Acronis Secure Zone be00 Solaris boot bf00 Solaris root bf01 Solaris /usr &amp; Mac Z bf02 Solaris swap bf03 Solaris backup bf04 Solaris /var bf05 Solaris /home bf06 Solaris alternate se bf07 Solaris Reserved 1 bf08 Solaris Reserved 2 bf09 Solaris Reserved 3 bf0a Solaris Reserved 4 bf0b Solaris Reserved 5 c001 HP-UX data c002 HP-UX service ea00 Freedesktop $BOOT eb00 Haiku BFS ed00 Sony system partitio ed01 Lenovo system partitef00 EFI System ef01 MBR partition scheme ef02 BIOS boot partitionf800 Ceph OSD f801 Ceph dm-crypt OSD f802 Ceph journal f803 Ceph dm-crypt journa f804 Ceph disk in creatio f805 Ceph dm-crypt disk ifb00 VMWare VMFS fb01 VMWare reserved fc00 VMWare kcore crash pfd00 Linux RAID 刻录iso镜像到U盘必须先change a partition’s type code -&gt;EF00再 ‘dd’ Example disk’s GPT12345678910111213141516Disk /dev/sda: 468862128 sectors, 223.6 GiBLogical sector size: 512 bytesDisk identifier (GUID): 4F2B2F55-48AC-4CC8-A745-605404C6BDF7Partition table holds up to 128 entriesFirst usable sector is 34, last usable sector is 468862094Partitions will be aligned on 2048-sector boundariesTotal free space is 13745 sectors (6.7 MiB)Number Start (sector) End (sector) Size Code Name 1 4096 204799 98.0 MiB EF00 EFI system partition 2 208896 229904940 109.5 GiB 0700 Basic data partition 3 229906432 230897663 484.0 MiB 2700 4 230899712 426919054 93.5 GiB 0700 Basic data partition 5 426919936 427309055 190.0 MiB 8300 6 427309056 428285951 477.0 MiB 8200 7 428285952 468860927 19.3 GiB 8300 details infomation on a partition1234567Partition GUID code: C12A7328-F81F-11D2-BA4B-00A0C93EC93B (EFI System)Partition unique GUID: 00772A36-9423-43A9-B1A1-0BE031102BFBFirst sector: 4096 (at 2.0 MiB)Last sector: 204799 (at 100.0 MiB)Partition size: 200704 sectors (98.0 MiB)Attribute flags: 0000000000000000Partition name: &apos;EFI system partition&apos;","raw":null,"content":null,"categories":[{"name":"Linux","slug":"Linux","permalink":"https://ygcaicn.github.io/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://ygcaicn.github.io/tags/Linux/"},{"name":"GPT","slug":"GPT","permalink":"https://ygcaicn.github.io/tags/GPT/"}]},{"title":"Python3 实现代理IP,伪装IP","slug":"proxy-python3","date":"2017-03-18T18:43:36.000Z","updated":"2018-01-15T13:21:48.246Z","comments":true,"path":"python3/proxy-python3.html","link":"","permalink":"https://ygcaicn.github.io/python3/proxy-python3.html","excerpt":"实现抓取代理服务器，建立ipPool,伪装外网ip","text":"实现抓取代理服务器，建立ipPool,伪装外网ip Proxy123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110#!/usr/bin/python3import urllib.requestimport reimport gzipdef ungzip(data): try: # try decompress print('compressing.....') data = gzip.decompress(data) print('dcompress done!') except: print('without compress!') return dataclass Proxy: def __init__(self,url='http://www.xicidaili.com/'): self.ipPool=[] self.url=url self.getipPool(); def getipPool(self): #get proxy Ip address pool from http://www.xicidaili.com/ # Base URL being accessed headers=&#123; 'Connection': 'keep-alive', 'Cache-Control': 'max-age=0', 'Upgrade-Insecure-Requests': '1', 'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/56.0.2924.87 Safari/537.36', 'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8', 'Accept-Encoding': 'gzip, deflate, sdch', 'Accept-Language': 'zh-CN,zh;q=0.8,en;q=0.6', &#125; # Make a GET request and read the response req = urllib.request.Request(self.url,headers=headers) response = urllib.request.urlopen(req) res_bytes = ungzip(response.read()) html_str = res_bytes.decode(encoding='utf-8') # the pattern(Regular expression) is depend on the response data from your url pattern = r'\\s*&lt;td&gt;(((2[0-4]\\d|25[0-5]|[01]?\\d\\d?)\\.)&#123;3&#125;(2[0-4]\\d|25[0-5]|[01]?\\d\\d?))&lt;/td&gt;\\s*\\n\\s*&lt;td&gt;(\\d&#123;2,5&#125;)&lt;/td&gt;\\s*\\n\\s*&lt;td&gt;(\\w+)&lt;/td&gt;\\s*\\n\\s*&lt;td class=\"country\"&gt;透明&lt;/td&gt;\\s*\\n\\s*&lt;td&gt;(HTTP|HTTPS)&lt;/td&gt;' regex = re.compile(pattern) s = regex.findall(html_str) #s = [('221.204.103.145', '103.', '103', '145', '9797', '山西太原', 'HTTP'), ...] for host in s: hostdict = &#123;'host':host[0],'port':host[4],'country':host[5],'protocol':host[-1]&#125; self.ipPool.append(hostdict) return self.ipPool def startProxy(self): self.printIpPool(); host_num = input('Please select a host:') host_num = int(host_num.strip()) proxy = &#123;'http':self.ipPool[host_num]['host']+':'+self.ipPool[host_num]['port']&#125; #creat ProxyHandler proxy_support = urllib.request.ProxyHandler(proxy) #creat Opener opener = urllib.request.build_opener(proxy_support) #creat User Angent #opener.addheaders = [('User-Agent','Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/56.0.2924.87 Safari/537.36')] #install OPener urllib.request.install_opener(opener) #start Opener pass def printIpPool(self): for i in range(0,len(self.ipPool)): print(i,\":\",self.ipPool[i])if __name__ == '__main__': url = \"http://ip.cn/\" headers=&#123; 'Connection': 'keep-alive', 'Cache-Control': 'max-age=0', 'Upgrade-Insecure-Requests': '1', 'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/56.0.2924.87 Safari/537.36', 'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8', 'Accept-Encoding': 'gzip, deflate, sdch', 'Accept-Language': 'zh-CN,zh;q=0.8,en;q=0.6', #'Cookie': 'UM_distinctid=15ae0d3744b437-0ebcb4eece40e4-57e1b3c-100200-15ae0d3744c42b; CNZZDATA123770=cnzz_eid%3D646344926-1484393339-%26ntime%3D1489830206' &#125; proxyhost = Proxy() proxyhost.startProxy() req = urllib.request.Request(url,headers=headers) response = urllib.request.urlopen(req) res_bytes = ungzip(response.read()) html_str = res_bytes.decode(encoding='utf-8') file_html = open(\"proxy.html\",'w',encoding = \"utf-8\") file_html.write(html_str) file_html.close() # the pattern(Regular expression) is depend on the response data from your url #pattern = r'((\\d&#123;1,3&#125;\\.)&#123;3&#125;\\d&#123;1,3&#125;)' pattern = r'&lt;code&gt;(((2[0-4]\\d|25[0-5]|[01]?\\d\\d?)\\.)&#123;3&#125;(2[0-4]\\d|25[0-5]|[01]?\\d\\d?))&lt;/code&gt;' pattern2 = r'所在地理位置：&lt;code&gt;([\\s\\w]*)&lt;/code&gt;' my_locate = re.findall(pattern2,html_str) my_locate = my_locate[0] my_ip = re.findall(pattern,html_str) my_ip = my_ip[0][0] #print(html_str) print('my locate:',my_locate) print('my ip:',my_ip) get proxy Ip address pool from http://www.xicidaili.com/直接get得到主页以后，主要是写正则表达式，match得到我们需要的数据。 得到的html数据： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;/tr&gt; &lt;tr class=\"subtitle\"&gt; &lt;th class=\"country\"&gt;国家&lt;/th&gt; &lt;th&gt;代理IP地址&lt;/th&gt; &lt;th&gt;端口&lt;/th&gt; &lt;th width=\"20%\"&gt;服务器地址&lt;/th&gt; &lt;th class=\"country\"&gt;是否匿名&lt;/th&gt; &lt;th&gt;类型&lt;/th&gt; &lt;th width=\"11%\"&gt;存活时间&lt;/th&gt; &lt;th width=\"12%\"&gt;验证时间&lt;/th&gt; &lt;/tr&gt; &lt;tr class=\"odd\"&gt; &lt;td class=\"country\"&gt;&lt;img src=\"http://fs.xicidaili.com/images/flag/cn.png\" alt=\"Cn\" /&gt;&lt;/td&gt; &lt;td&gt;115.231.175.68&lt;/td&gt; &lt;td&gt;8081&lt;/td&gt; &lt;td&gt;浙江杭州&lt;/td&gt; &lt;td class=\"country\"&gt;透明&lt;/td&gt; &lt;td&gt;HTTP&lt;/td&gt; &lt;td&gt;74天&lt;/td&gt; &lt;td&gt;不到1分钟&lt;/td&gt; &lt;/tr&gt; &lt;tr class=\"\"&gt; &lt;td class=\"country\"&gt;&lt;img src=\"http://fs.xicidaili.com/images/flag/cn.png\" alt=\"Cn\" /&gt;&lt;/td&gt; &lt;td&gt;220.191.1.130&lt;/td&gt; &lt;td&gt;8118&lt;/td&gt; &lt;td&gt;浙江杭州&lt;/td&gt; &lt;td class=\"country\"&gt;透明&lt;/td&gt; &lt;td&gt;HTTP&lt;/td&gt; &lt;td&gt;16小时&lt;/td&gt; &lt;td&gt;1分钟前&lt;/td&gt; &lt;/tr&gt; &lt;tr class=\"odd\"&gt; &lt;td class=\"country\"&gt;&lt;img src=\"http://fs.xicidaili.com/images/flag/cn.png\" alt=\"Cn\" /&gt;&lt;/td&gt; &lt;td&gt;124.88.67.54&lt;/td&gt; &lt;td&gt;80&lt;/td&gt; &lt;td&gt;新疆乌鲁木齐&lt;/td&gt; &lt;td class=\"country\"&gt;透明&lt;/td&gt; &lt;td&gt;HTTP&lt;/td&gt; &lt;td&gt;723天&lt;/td&gt; &lt;td&gt;13分钟前&lt;/td&gt; &lt;/tr&gt; &lt;tr class=\"\"&gt; &lt;td class=\"country\"&gt;&lt;img src=\"http://fs.xicidaili.com/images/flag/cn.png\" alt=\"Cn\" /&gt;&lt;/td&gt; &lt;td&gt;58.221.59.210&lt;/td&gt; &lt;td&gt;63000&lt;/td&gt; &lt;td&gt;江苏南通&lt;/td&gt; &lt;td class=\"country\"&gt;透明&lt;/td&gt; &lt;td&gt;HTTP&lt;/td&gt; &lt;td&gt;362天&lt;/td&gt; &lt;td&gt;1小时前&lt;/td&gt; &lt;/tr&gt; 我们这里匹配出主机ip（host），port，country和protocol，利用deerchao的正则表达式测试器很设计出下面的正则表达式： #the pattern(Regular expression) is depend on the response data from your url pattern = r&#39;\\s*&lt;td&gt;(((2[0-4]\\d|25[0-5]|[01]?\\d\\d?)\\.){3}(2[0-4]\\d|25[0-5]|[01]?\\d\\d?))&lt;/td&gt;\\s*\\n\\s*&lt;td&gt;(\\d{2,5})&lt;/td&gt;\\s*\\n\\s*&lt;td&gt;(\\w+)&lt;/td&gt;\\s*\\n\\s*&lt;td class=&quot;country&quot;&gt;透明&lt;/td&gt;\\s*\\n\\s*&lt;td&gt;(HTTP|HTTPS)&lt;/td&gt;&#39; 最终的效果： 运行程序，会提示我们选择一个代理服务器，程序然后会去访问ip.cn,通过返回的数据我们解析得到外网IP，会发现这和我们选择的代理服务器信息是一致的而不是我们自己的外网地址。ip伪装成功。 参考正则表达式：http://deerchao.net/tutorials/regex/regex.htm","raw":null,"content":null,"categories":[{"name":"python3","slug":"python3","permalink":"https://ygcaicn.github.io/categories/python3/"}],"tags":[{"name":"Python3","slug":"Python3","permalink":"https://ygcaicn.github.io/tags/Python3/"},{"name":"正则表达式","slug":"正则表达式","permalink":"https://ygcaicn.github.io/tags/正则表达式/"},{"name":"IP伪装","slug":"IP伪装","permalink":"https://ygcaicn.github.io/tags/IP伪装/"},{"name":"代理","slug":"代理","permalink":"https://ygcaicn.github.io/tags/代理/"}]},{"title":"LEDE-Mt7620a-newifiY1","slug":"LEDE-Mt7620a-newifiY1","date":"2017-03-16T15:56:12.000Z","updated":"2018-01-15T10:22:08.174Z","comments":true,"path":"嵌入式/LEDE-Mt7620a-newifiY1.html","link":"","permalink":"https://ygcaicn.github.io/嵌入式/LEDE-Mt7620a-newifiY1.html","excerpt":"LEDE:https://downloads.lede-project.org\nLEDE Packages(mipsel_24kc):http://openwrt-dist.sourceforge.net/packages/LEDE/base/mipsel_24kc/","text":"LEDE:https://downloads.lede-project.org LEDE Packages(mipsel_24kc):http://openwrt-dist.sourceforge.net/packages/LEDE/base/mipsel_24kc/ 1234567891011121314151617181920root@LEDE:/tmp# opkg install libudns_0.4-1_mipsel_24kc.ipkInstalling libudns (0.4-1) to root...Configuring libudns.root@LEDE:/tmp# opkg install shadowsocks-libev_3.0.3-1_mipsel_24kc.ipk luci-app-shadowsocks_1.6.2-1_all.ipkInstalling shadowsocks-libev (3.0.3-1) to root...Installing libev (4.22-1) to root...Downloading http://downloads.lede-project.org/releases/17.01.0/packages/mipsel_24kc/packages/libev_4.22-1_mipsel_24kc.ipkInstalling libpcre (8.40-1) to root...Downloading http://downloads.lede-project.org/releases/17.01.0/packages/mipsel_24kc/packages/libpcre_8.40-1_mipsel_24kc.ipkInstalling libsodium (1.0.11-2) to root...Downloading http://downloads.lede-project.org/releases/17.01.0/packages/mipsel_24kc/packages/libsodium_1.0.11-2_mipsel_24kc.ipkInstalling libmbedtls (2.4.0-2) to root...Downloading http://downloads.lede-project.org/releases/17.01.0/packages/mipsel_24kc/base/libmbedtls_2.4.0-2_mipsel_24kc.ipkInstalling luci-app-shadowsocks (1.6.2-1) to root...Configuring libev.Configuring libpcre.Configuring libsodium.Configuring libmbedtls.Configuring shadowsocks-libev.Configuring luci-app-shadowsocks. 12345root@LEDE:/tmp# opkg install ChinaDNS_1.3.2-4_mipsel_24kc.ipk luci-app-chinadns_1.6.0-1_all.ipkInstalling ChinaDNS (1.3.2-4) to root...Installing luci-app-chinadns (1.6.0-1) to root...Configuring ChinaDNS.Configuring luci-app-chinadns. 12345root@LEDE:/tmp# opkg install dns-forwarder_1.1.1-1_mipsel_24kc.ipk luci-app-dns-forwarder_1.6.0-1_all.ipkInstalling dns-forwarder (1.1.1-1) to root...Installing luci-app-dns-forwarder (1.6.0-1) to root...Configuring dns-forwarder.Configuring luci-app-dns-forwarder. Kcptun+Shadowsocksopen source Project： openwrt kcptun https://github.com/bettermanbao/openwrt-kcptun More details please refer to https://github.com/xtaci/kcptun luci-app-kcptun please refer to https://github.com/kuoruan/luci-app-kcptun GUI for KCPTun windows client https://github.com/dfdragon/kcptun_gclient Kcptun for Android https://github.com/shadowsocks/kcptun-android 两端参数必须一致的有: datashard –前向纠错 parityshard –前向纠错\\ nocomp –压缩\\ key –密钥\\ crypt –加密算法\\ 其余为两边可独立设定的参数 1nocomp;mtu=1200;parityshard=0;key=waggywn@10000 dscp=46;mode=fast;crypt=salsa20;sndwnd=1024;rcvwnd=2048","raw":null,"content":null,"categories":[{"name":"嵌入式","slug":"嵌入式","permalink":"https://ygcaicn.github.io/categories/嵌入式/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://ygcaicn.github.io/tags/Linux/"},{"name":"openwrt","slug":"openwrt","permalink":"https://ygcaicn.github.io/tags/openwrt/"},{"name":"路由器","slug":"路由器","permalink":"https://ygcaicn.github.io/tags/路由器/"},{"name":"LEDE","slug":"LEDE","permalink":"https://ygcaicn.github.io/tags/LEDE/"}]},{"title":"help-linux","slug":"help-linux","date":"2017-03-15T14:01:55.000Z","updated":"2018-01-15T10:21:26.740Z","comments":true,"path":"Linux/help-linux.html","link":"","permalink":"https://ygcaicn.github.io/Linux/help-linux.html","excerpt":"Help LinuxUbuntu发行版列表WIKIUbuntu版本的命名规则是根据正式版发行的年月命名，Ubuntu 8.10也就意味着2008年10月发行的Ubuntu，研发人员与使用者可从版本号码就知道正式发布的时间。Ubuntu是基于Debian开发的Linux发行版，Debian的开发代号来自于电影玩具总动员，不过，Ubuntu各版本的代号却固定是形容词加上动物名称，而且这2个词的英文首字母一定是相同的。从Ubuntu 6.06开始，两个词的首字母按照英文字母表的排列顺序取用\n","text":"Help LinuxUbuntu发行版列表WIKIUbuntu版本的命名规则是根据正式版发行的年月命名，Ubuntu 8.10也就意味着2008年10月发行的Ubuntu，研发人员与使用者可从版本号码就知道正式发布的时间。Ubuntu是基于Debian开发的Linux发行版，Debian的开发代号来自于电影玩具总动员，不过，Ubuntu各版本的代号却固定是形容词加上动物名称，而且这2个词的英文首字母一定是相同的。从Ubuntu 6.06开始，两个词的首字母按照英文字母表的排列顺序取用 manpage按照开发代号分类了各个版本的man,也可以通过Toolsbar的版本号直接选择相应的版本。 help Ubuntu同样按照版本号和开发代号进行了分类，同时文档的类型分为Desktop，Server，InstallGuide。 DebianDebian Debian 中文参考手册 RaspberryRaspbian","raw":null,"content":null,"categories":[{"name":"Linux","slug":"Linux","permalink":"https://ygcaicn.github.io/categories/Linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://ygcaicn.github.io/tags/linux/"},{"name":"ubuntu","slug":"ubuntu","permalink":"https://ygcaicn.github.io/tags/ubuntu/"},{"name":"debian","slug":"debian","permalink":"https://ygcaicn.github.io/tags/debian/"},{"name":"raspberry","slug":"raspberry","permalink":"https://ygcaicn.github.io/tags/raspberry/"}]},{"title":"hello md","slug":"hello-md","date":"2017-03-05T10:08:28.000Z","updated":"2018-01-15T11:02:24.880Z","comments":true,"path":"杂项/hello-md.html","link":"","permalink":"https://ygcaicn.github.io/杂项/hello-md.html","excerpt":"MarkDown 文本编辑器：  \n\nMarkdownPad（我使用的是Markdownpad2）\nSublime\nAtom\n有道云笔记（直接存入云笔记很方便）\n任何有文本编辑功能的软件都可以书写markdown\n","text":"MarkDown 文本编辑器： MarkdownPad（我使用的是Markdownpad2） Sublime Atom 有道云笔记（直接存入云笔记很方便） 任何有文本编辑功能的软件都可以书写markdown Hello word！打开Markdown编辑器，新建Hello.md文件，写入下面的内容： 1234Hello world!===I love [Google](http://www.google.com)! 可视化以后的效果： Hello world!I love Google! 关于MarkdownPad2 官方MarkdownPad2,可以下载Pro版本。 破解注册码 邮箱：Soar360@live.com授权秘钥：GBPduHjWfJU1mZqcPM3BikjYKF6xKhlKIys3i1MU2eJHqWGImDHzWdD6xhMNLGVpbP2M5SN6bnxn2kSE8qHqNY5QaaRxmO3YSMHxlv2EYpjdwLcPwfeTG7kUdnhKE0vVy4RidP6Y2wZ0q74f47fzsZo45JE2hfQBFi2O9Jldjp1mW8HUpTtLA2a5/sQytXJUQl/QKO0jUQY4pa5CCx20sV1ClOTZtAGngSOJtIOFXK599sBr5aIEFyH0K7H4BoNMiiDMnxt1rD8Vb/ikJdhGMMQr0R4B+L3nWU97eaVPTRKfWGDE8/eAgKzpGwrQQoDh+nzX1xoVQ8NAuH+s4UcSeQ==","raw":null,"content":null,"categories":[{"name":"杂项","slug":"杂项","permalink":"https://ygcaicn.github.io/categories/杂项/"}],"tags":[{"name":"Markdown","slug":"Markdown","permalink":"https://ygcaicn.github.io/tags/Markdown/"}]},{"title":"Markdown 基础语法","slug":"markdown","date":"2017-03-05T09:58:19.000Z","updated":"2018-01-15T10:22:24.425Z","comments":true,"path":"杂项/markdown.html","link":"","permalink":"https://ygcaicn.github.io/杂项/markdown.html","excerpt":"JOHN GRUBER定义的markdown语法。","text":"JOHN GRUBER定义的markdown语法。 段落与换行1.段落的前后必须空行：空行指的是什么内容都没有，或者只有空白符（空格或制表符） 相邻两行文本，如果中间没有空行会显示在一行中（换行符被转换成为空格） 2.如果需要在段落内加入换行（&lt;br/&gt;）可以在前一行的末尾加入至少两个空格，然后换行写其他的文字 3.Markdown中的多数区域都需要在两个空行之间 标题Setext格式12345H1====H2---- 渲染效果：（不包含上下的分隔线） H1H2 atx格式 可以使用对称的#包括文本： 123## H2 ##### H3 ### 对于有道云笔记文本和#之间必须有空格。 标准语法就是这样的。 渲染效果： H2H3 也可以只在左边使用#: 123### H3#### H4 渲染效果： H3H4 JOHN’s Heaser 123456789101112131415161718192021222324252627HEADERSMarkdown supports two styles of headers, Setext and atx.Setext-style headers are “underlined” using equal signs (for first-level headers) and dashes (for second-level headers). For example:This is an H1=============This is an H2-------------Any number of underlining =’s or -’s will work.Atx-style headers use 1-6 hash characters at the start of the line, corresponding to header levels 1-6. For example:# This is an H1## This is an H2###### This is an H6Optionally, you may “close” atx-style headers. This is purely cosmetic — you can use this if you think it looks better. The closing hashes don’t even need to match the number of hashes used to open the header. (The number of opening hashes determines the header level.) :# This is an H1 ### This is an H2 ##### This is an H3 ###### 各种Markdown软件的渲染结果可能会有一些差别，但是了解一下标准的语法是没坏处的。 引用1.引用内容在段落或者内容前使用&gt;符号，就可以将这段内容标记为‘引用’的内容（&lt;blockquote&gt;）: 1&gt;引用内容 渲染效果： 引用内容 2.多行引用12&gt;多行引用&gt;可以在每一行前加`&gt;`符号 渲染效果： 多行引用可以在每一行前加&gt;符号 12&gt;如果仅在第一行使用`&gt;`,后面相邻的行即使省略`&gt;`，也会变成引用内容 渲染效果： 如果仅在第一行使用&gt;,后面相邻的行即使省略&gt;，也会变成引用内容 1234&gt;如果引用的内容需要换行， &gt;可以在行尾添加两个空格&gt;&gt;或者在引用内容中加一个空行 渲染效果： 如果引用的内容需要换行，可以在行尾添加两个空格 或者在引用内容中加一个空行 3.嵌套引用12&gt;也可以在引用中&gt;&gt;使用嵌套的引用 渲染效果： 也可以在引用中 使用嵌套的引用 4.其它Markdown1&gt;在引用中可以使用其它任何*Markdown*语法 渲染效果： 在引用中可以使用其它任何Markdown语法 列表无序列表123* 可以使用`*`作为标记- 也可以使用`-`+ 或者`+` 渲染效果： 可以使用*作为标记 也可以使用- 或者+ 有序列表1231. 有序列表以数字和`.`开始；2. 数字的序列并不会影响生成列表的序列；4. 但是仍然推荐按照自然顺序（1.2.3...）编写 渲染效果： 有序列表以数字和.开始； 数字的序列并不会影响生成列表的序列； 但是仍然推荐按照自然顺序（1.2.3…）编写 嵌套的列表123456781. 第一层 + 1-1 + 1-2 + 1-32. 无序列表和有序列表可以随意相互嵌套 1. 2-1 2. 2-2 3. 2-3 渲染效果： 第一层 1-1 1-2 1-3 无序列表和有序列表可以随意相互嵌套 2-1 2-2 2-3 语法和用法 无序列表项的开始是：符号 空格； 有序列表项的开始是：数字 . 空格； 空格至少为一个，多个空格将被解析为一个； 如果仅需要在行前显示数字和.: 105\\. 可以使用：数字\\. 来取消显示为列表 05. 可以使用：数字\\. 来取消显示为列表 代码代码块可以使用缩进来插入代码块： &lt;html&gt; &lt;title&gt;&lt;/title&gt; &lt;/html&gt; 代码块前后至少有一个空行，切每行代码前至少有一个Tab或者四个空格； 行内代码通过`，插入行内代码（是Tab键上边、数字1键左侧的按键）； 例如&lt;title&gt;Markdown&lt;/title&gt; 转换规则代码块中的文本（包括Markdown语法）都会显示为原始内容，而特殊字符会被转换为HTML字符实体 分割线 可以在一行中使用三个或更多的*,-或_来添加分隔线(): 多个字符之间可以有空格（空白符），但不能有其它字符： 123456***------_____* * *_ _ _ 渲染效果： * 超链接行内式格式为：[link text](URL &quot;title text&quot;) [Google](http://www.google.com)Google [icon](./images/icon.png)icon 超链接的title就是鼠标放上去（不是点击）时就弹出来的提示： [Google](http://www.google.com &quot;Google Title&quot;) 注：title text使用’或者”都是可以的。 Google 参考式参考式链接的写法相当于行内式拆分成两部分，并通过一个识别符连链接两部分。参考式能尽量保持文章的结构简单，也方便统一管理URL 链接格式 第一个方括号为链接文本，第二个方括号为 链接独有的标识符，可以是字母、数字、空格或标点符号。标识符是不区分大小写的 [link text][link-sign] 链接内容 其中URL可以使用&lt;&gt;包起来，title可以使用’’、””、 ()包括（考虑到兼容性，建议使用引号），title部分也可以换行来写； 链接内容的定义可以放在同一个文件的任意位置； 备注 可以省略标识符，直接使用link text作为标识符。 这种情况下第二个方括号可以为空或者直接省略第二个方括号。 参考格式的优点在于可以在多个不同的位置引用同一个URL。 123456789[Google][google-link] [Baidu][baidu-link] [QQ][] [Amazon][google-link]: http://www.google.com &quot;Google Title&quot;[baidu-link]: http://www.baidu.com &quot;Baidu Title&quot;[QQ]: http://www.qq.com &quot;QQ Title&quot;[Amazon]: http://www.amazon.com &quot;amazon title&quot; 渲染效果： GoogleBaiduQQAmazon 自动链接使用&lt;&gt;包括的URL或者邮箱地址会被自动的转换为超链接： 12&lt;http://www.google.com&gt; &lt;123@email.com&gt; 渲染效果： http://www.google.com&#x31;&#50;&#x33;&#x40;&#x65;&#x6d;&#97;&#x69;&#x6c;&#46;&#99;&#x6f;&#109; 这种方式适合行内较短的链接，会使用URL作为超链接文章，邮箱地址会自动编码，以逃避抓取机器人。 图片插入图片的语法和插入超链接的语法基本一致，只是在最前面多一个!。也分为行内式和参考式两种。 行内式1![Imgur](http://i.imgur.com/YACdsVS.jpg) 方括号部分是图片的替代文本，括号中的’title’部分和连接是一样的，是可选的。 参考式123![Imgur][rosse][rosse]: http://i.imgur.com/YACdsVS.jpg &quot;rosse&quot; 指定图片的大小Markdown不支持指定图片的大小，不过可以通过直接插入标签来指定相关属性： 1&lt;img src=&quot;http://i.imgur.com/YACdsVS.jpg&quot; alt=&quot;rosse&quot; title=&quot;rosse&quot; width=&quot;50&quot; height=&quot;30&quot;/&gt; 注：这在有道云笔记里是不支持的！ 强调 使用* *或_ _包括的文本会被转换为,通常表现为斜体。 使用** **或__ __包括的文本会被转换为,通常表现为加粗。 用来包括文本的或_内侧不能有空白，否则 _将不会被转换。 如果需要在文本中成对显示*或者_，可以在符号前加入\\即可。 强调的特殊符号必须成对使用。 123456*Hello world!* _Hello world!_ **Hello world!** __Hello world!__ \\*Hello world!\\* \\_Hello world!\\_ Hello world!Hello world!Hello world!Hello world!*Hello world!*_Hello world!_ 字符转义反斜线 \\用于插入在Markdown语法中有特殊作用的字符。 这些字符包括： 12345678910111213\\ ` _ &#123;&#125; [] () # + - _ &apos; . ! Markdown 扩展语法Markdown标准 本身包含的功能有限，所以产生了许多第三方的扩展语法，如Github Flavored Markdown。 删除线用~~ ~~包括的内容将以删除线的形式展现。 1~~删除线~~ 删除线 代码块和语法高亮代码块 与缩进添加代码块不同，这里使用 \\来包含多行代码。```需要单独占一行。1234567891011122. 在第一组```之后添加代码的语言，如&apos;javascript&apos;或者&apos;js&apos;，即可以将代码标记为Javascript。 ```c++ include&lt;iostream&gt; using namespace std; int main(void) &#123; cout &lt;&lt; &quot;Hello world!&quot;; return 0; &#125; 1234567include&lt;iostream&gt;using namespace std;int main(void)&#123; cout &lt;&lt; \"Hello world!\";&#125; 1window.addEventListener('load', function() &#123;console.log('window loaded');&#125;); 1window.addEventListener('load', function() &#123;console.log('window loaded');&#125;); 表格单元格和表头 使用|来分隔不同的单元格，使用来分隔表头和其它行。 为了美观，可以使用空格对齐不同的单元格，并在左右两侧都使用 |来标记单元格边界。 在表头下方的分隔线中加入 :，即可标记下方单元格内容的对齐方式。单元格内容默认为左对齐，表头内容会一直居中对齐。 表格中可以插入其它Markdown内容的行内标记，比如超链接等。 1234| name | age ||---------- |-----------||LearnShare | 12 ||Mike | 20 | name age LearnShare 12 Mike 20 name age blog LearnShare 12 Learn Mike 20 Task list123456- [ ] Eat- [x] Code - [x] HTML - [X] CSS - [ ] Javascipt- [ ]Sleep [ ] Eat [x] Code [x] HTML [x] CSS [ ] Javascipt [ ]Sleep 编辑器与扩展这部分给大家介绍一些可以用来书写、编辑Markdown的工具，包括独立客户端、编辑器/IDE插件，以及WEB的工具，排名不分先后。 也欢迎你来推荐自己喜欢的工具和插件。 MarkdownPad Windows Text Windows OSX MarkPad Windows MdCharm Windows Linux Mardown Edit Windows CuteMarkEdWindows Linux Haroopad Windows OSX Linux Mou OSX MacDown OSX Markdown Pro OSX ReTextLinux sublime-markdown-extendedSublime Text Atom Markdown PreviewAtom IDEA MarkdownIDEA cmd MarkdownWindows OSX Linux web StactEditWeb DillingerWeb","raw":null,"content":null,"categories":[{"name":"杂项","slug":"杂项","permalink":"https://ygcaicn.github.io/categories/杂项/"}],"tags":[{"name":"markdown","slug":"markdown","permalink":"https://ygcaicn.github.io/tags/markdown/"}]},{"title":"CentOS下载及版本选择--Linux版本，下载","slug":"CentOS下载及版本选择-Linux版本，下载","date":"2017-01-15T15:02:06.000Z","updated":"2018-01-15T09:58:46.582Z","comments":true,"path":"Linux/CentOS下载及版本选择-Linux版本，下载.html","link":"","permalink":"https://ygcaicn.github.io/Linux/CentOS下载及版本选择-Linux版本，下载.html","excerpt":"CentOS 是一个企业级的 Linux 发行版本，它源于 Red Hat 1 免费公开的源代码。CentOS 完全遵守 Red Hat 的再发行政策，并且以功能上的兼容性为目标。CentOS 对组件的修改主要是去除上游供应商的商标及美工。","text":"CentOS 是一个企业级的 Linux 发行版本，它源于 Red Hat 1 免费公开的源代码。CentOS 完全遵守 Red Hat 的再发行政策，并且以功能上的兼容性为目标。CentOS 对组件的修改主要是去除上游供应商的商标及美工。 镜像目录结构：123456789101112131415161718190_README.txt 22-May-2016 13:52 2210CentOS-6.8-x86_64-LiveCD.iso 22-May-2016 22:18 702MCentOS-6.8-x86_64-LiveCD.torrent 25-May-2016 18:01 28KCentOS-6.8-x86_64-LiveDVD.iso 22-May-2016 21:38 2GCentOS-6.8-x86_64-LiveDVD.torrent 25-May-2016 18:01 76KCentOS-6.8-x86_64-bin-DVD1.iso 23-May-2016 07:53 4GCentOS-6.8-x86_64-bin-DVD1to2.torrent 25-May-2016 18:01 229KCentOS-6.8-x86_64-bin-DVD2.iso 23-May-2016 07:53 2GCentOS-6.8-x86_64-minimal.iso 24-May-2016 00:37 447MCentOS-6.8-x86_64-minimal.torrent 25-May-2016 18:01 18KCentOS-6.8-x86_64-netinstall.iso 22-May-2016 14:07 228MCentOS-6.8-x86_64-netinstall.torrent 25-May-2016 18:01 9799README.txt 22-May-2016 13:52 2210md5sum.txt 24-May-2016 00:41 388md5sum.txt.asc 25-May-2016 17:57 1271sha1sum.txt 24-May-2016 00:41 436sha1sum.txt.asc 25-May-2016 17:57 1319sha256sum.txt 24-May-2016 00:41 580sha256sum.txt.asc 25-May-2016 17:58 1463 README.txt有说明12345678910111213141516171819202122232425262728293031What images are in this directoryCentOS-6.8-x86_64-netinstall.iso This is the network install and rescue image. This image is designed to be burned onto a CD. You then boot your computer off the CD.CentOS-6.8-x86_64-minimal.iso The aim of this image is to install a very basic CentOS 6.8 system, with the minimum of packages needed to have a functional system. Please burn this image onto a CD and boot your computer off it. A preselected set of packages will be installed on your system. Everything else needs to be installed using yum. Please read http://wiki.centos.org/Manuals/ReleaseNotes/CentOSMinimalCD6.8 for more details about this image. The set of packages installed by this image is identical to the one installed when choosing the group named &quot;Minimal&quot; from the full DVD image.CentOS-6.8-x86_64-bin-DVD1.isoCentOS-6.8-x86_64-bin-DVD2.iso These two dvd images contain the entire base distribution. Please burn DVD1 onto a DVD and boot your computer off it. A basic install will not need DVD2. After the installation is complete, please run &quot;yum update&quot; in order to update your system.CentOS-6.8-x86_64-LiveCD.iso This is a CD live image of CentOS 6.8 designed to be burned onto a CD. You then boot your computer using that CD. Please read http://wiki.centos.org/Manuals/ReleaseNotes/CentOSLiveCD6.8 for more details about this image. The disk can also be used to install CentOS 6.8 onto your computer but without offering any package selection options at install time.CentOS-6.8-x86_64-LiveDVD.iso This is a DVD live image of CentOS 6.8 designed to be burned onto a DVD. You then boot your computer using that DVD. Please read http://wiki.centos.org/Manuals/ReleaseNotes/CentOSLiveDVD6.8 for more details about this image. The disk can also be used to install CentOS 6.8 onto your computer but without offering any package selection options at install time. Remember that in order to be able to partition your disk you will need to run the GUI installer which in turns needs enough RAM. The same is true for the network setup step. The release notes ( http://wiki.centos.org/Manuals/ReleaseNotes/CentOS6.8 ) provide more details about these aspects. LiveDVD-LiveCD-DVD123CentOS-6.8-x86_64-LiveCD.isoCentOS-6.8-x86_64-LiveDVD.iso 这两个live版不许要安装到硬盘，可以直接从介质启动系统。LiveCD版——相比LiveDVD是个精简的光盘CentOS系统。体积更小，便于维护使用。 123CentOS-6.8-x86_64-bin-DVD1.isoCentOS-6.8-x86_64-bin-DVD2.iso 这两个镜像是系统安装的镜像，需要安装到硬盘才能使用。DVD1用与基础安装，DVD2为附加RPM包，安装系统时只需要用到DVD1。另外这两个镜像可以作为本地yum源使用。 1CentOS-6.8-x86_64-minimal.iso 最小化安装镜像，very basic CentOS 6.8 system。 1CentOS-6.8-x86_64-netinstall.iso 网络安装镜像，需要联网才能进行安装。 参考文档：https://wiki.centos.org/zh/Manuals/ReleaseNotes/CentOS6.8#Linux下载开源镜像站： 1.企业贡献： 搜狐开源镜像站：http://mirrors.sohu.com/ 网易开源镜像站：http://mirrors.163.com/ 2.大学教学： 北京理工大学： http://mirror.bit.edu.cn (IPv4 only) http://mirror.bit6.edu.cn (IPv6 only) 北京交通大学： http://mirror.bjtu.edu.cn (IPv4 only) http://mirror6.bjtu.edu.cn (IPv6 only) http://debian.bjtu.edu.cn (IPv4+IPv6) 兰州大学：http://mirror.lzu.edu.cn/ 厦门大学：http://mirrors.xmu.edu.cn/ 上海交通大学： http://ftp.sjtu.edu.cn/ (IPv4 only) http://ftp6.sjtu.edu.cn (IPv6 only) 清华大学： http://mirrors.tuna.tsinghua.edu.cn/ (IPv4+IPv6) http://mirrors.6.tuna.tsinghua.edu.cn/ (IPv6 only) http://mirrors.4.tuna.tsinghua.edu.cn/ (IPv4 only) 天津大学：http://mirror.tju.edu.cn/ 中国科学技术大学： http://mirrors.ustc.edu.cn/ (IPv4+IPv6) http://mirrors4.ustc.edu.cn/ http://mirrors6.ustc.edu.cn/ 西南大学：http://linux.swu.edu.cn/swudownload/Distributions/ 东北大学： http://mirror.neu.edu.cn/ (IPv4 only) http://mirror.neu6.edu.cn/ (IPv6 only) 电子科技大学： http://ubuntu.uestc.edu.cn/ 青岛大学：http://mirror.qdu.edu.cn/","raw":null,"content":null,"categories":[{"name":"Linux","slug":"Linux","permalink":"https://ygcaicn.github.io/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://ygcaicn.github.io/tags/Linux/"}]},{"title":"UEFI 启动：实际工作原理","slug":"grub2-1","date":"2016-11-06T04:07:01.000Z","updated":"2018-01-15T10:19:14.051Z","comments":true,"path":"Linux/grub2-1.html","link":"","permalink":"https://ygcaicn.github.io/Linux/grub2-1.html","excerpt":"（译）转 UEFI 启动：实际工作原理 2014.05.28\n本文是我翻译自国外技术博客的一篇文章，其中讲述了 UEFI 的一些基本概念和细节。\n本文的原始链接位于：，https://www.happyassassin.net/2014/01/25/uefi-boot-how-does-that-actually-work-then/\n本人的翻译水平有限，难免多有疏漏。废话不多说，请看正文：\n又到 AdamW 的讲课时间了，如果你不想听我的长篇大论，那么请出门右拐。\nKamil Paral 说我有写作癖，知道自己的坏习惯也是件好事。\n可能你已经在互联网上阅读过有关 UEFI 的大量资料。但是有一些重要事项需要了解：这些资料中的 95% 都毫无价值。如果你认为你已经对 UEFI 有所了解，但是如果你的知识来源并不可靠，那么所掌握的知识就不过是一堆误解、谬论、一己之见、信口开河和弥天大谎。先把这些都忘了吧。如果想真正了解有关 UEFI 的权威知识，不妨访问 UEFI 规范、mjg59 的博客、其他靠谱一点的文章/权威人士——包括 Rod Smith、Peter Jones、Chris Murphy，或者阅读一些小众操作系统的文档，前提是这些操作系统的开发人员确实了解 UEFI。","text":"（译）转 UEFI 启动：实际工作原理 2014.05.28 本文是我翻译自国外技术博客的一篇文章，其中讲述了 UEFI 的一些基本概念和细节。 本文的原始链接位于：，https://www.happyassassin.net/2014/01/25/uefi-boot-how-does-that-actually-work-then/ 本人的翻译水平有限，难免多有疏漏。废话不多说，请看正文： 又到 AdamW 的讲课时间了，如果你不想听我的长篇大论，那么请出门右拐。 Kamil Paral 说我有写作癖，知道自己的坏习惯也是件好事。 可能你已经在互联网上阅读过有关 UEFI 的大量资料。但是有一些重要事项需要了解：这些资料中的 95% 都毫无价值。如果你认为你已经对 UEFI 有所了解，但是如果你的知识来源并不可靠，那么所掌握的知识就不过是一堆误解、谬论、一己之见、信口开河和弥天大谎。先把这些都忘了吧。如果想真正了解有关 UEFI 的权威知识，不妨访问 UEFI 规范、mjg59 的博客、其他靠谱一点的文章/权威人士——包括 Rod Smith、Peter Jones、Chris Murphy，或者阅读一些小众操作系统的文档，前提是这些操作系统的开发人员确实了解 UEFI。 好，准备工作做完了。我主要想讨论启动加载，因为对于大多数用户而言，固件在其中扮演着重要角色，同时，不少网站也针对这一过程喋喋不休，由此产生不少误解。 术语首先，我们了解一些术语。BIOS 和 UEFI 都是计算机的固件类型。BIOS 固件（主要）用于 IBM PC 兼容计算机。UEFI 的通用性更强，可用在非“IBM PC 兼容”系列的计算机上。 不存在“UEFI BIOS”。没有任何一台计算机会有“UEFI BIOS”。请不要再说“UEFI BIOS”。BIOS 不是所有 PC 固件的通用术语，它只是 PC 固件的一种特定类型。计算机中包含固件。如果你有一台 IBM PC 兼容计算机，那么固件几乎肯定就是 BIOS 或 UEFI。如果你运行的是 Coreboot，那么恭喜，你是个例外，引以为傲吧。 安全启动 (Secure Boot) 与 UEFI 不是同一个概念。请不要将这些术语混淆使用。安全启动 (Secure Boot) 实际上是 UEFI 规范的一项可选功能，于 UEFI 规范版本 2.2 引入。我们稍后会详细讨论安全启动 (Secure Boot) 到底是什么，但是目前而言，只需要记住它和 UEFI 不同即可。你需要区分安全启动 (Secure Boot) 和 UEFI 的差异，在任何场合，你都应当了解你实际上讨论的是其中哪一个。我们首先讨论 UEFI，然后我们将把安全启动 (Secure Boot) 作为 UEFI 的一项“扩展”来进行讨论，因为这就是安全启动 (Secure Boot) 的本质。 注释：UEFI 不是由微软开发的，也从来不受微软控制。它的前身和基础——EFI，是由 Intel 开发和发布的。UEFI 由 UEFI 论坛进行管理。微软是 UEFI 论坛的成员之一。Red Hat、Apple、几乎所有主要 PC 制造商、Intel（显然）、AMD 和一大批其他主要和次要硬件、软件和固件公司及组织也都是 UEFI 论坛的成员。UEFI 是一套业已达成广泛共识的规范，其中当然也包含各种混乱（我们稍后会专门讨论其中一部分）。UEFI 并不由任何一家公司独裁掌控。 参考资料如果想真正了解 UEFI，阅读 UEFI 规范是个不错的方法。这件事并不难，也不需要什么代价。阅读 UEFI 规范相当枯燥乏味，但是会让你受益匪浅。你可以从官方 UEFI 网站下载 UEFI 规范。尽管下载 UEFI 规范需要先同意某些条款和条件，但是不会带来损失。在我撰写本文时，UEFI 规范的最新版本是 2.4 Errata A（译者注：现在更新到了 2.4 Errata B），本文所写内容也基于这一版本。 BIOS 没有制定相应规范。BIOS 本身就是一项事实标准，从 20 世纪 80 年代开始，BIOS 的工作方式就一成不变。这也是诞生 UEFI 的原因之一。 简单起见，我们可以把 BIOS 和 UEFI 看成两种不同的组合。其中一种是 UEFI和 GPT （我们稍后会讨论 GPT）产生之前，IBM PC 兼容计算机（以下称为 PC）所广泛采用的组合。大部分人可能对这种组合非常熟悉，对其中的细节了如指掌。那么我们就先来讨论在具有 BIOS 固件的 PC 上，启动是如何工作的。 BIOS 启动事实上，BIOS 启动的工作原理非常非常简单。在老式 BIOS PC 上，装有一个或多个磁盘，每个磁盘中包含 MBR。MBR 是另一套事实标准；大体而言，磁盘起始位置以特定格式描述磁盘上的分区，并包含“启动装载程序 (boot loader)”，BIOS 固件知道如何执行这一小段启动装载程序代码。启动装载程序的职责是启动操作系统（现代启动装载程序的大小通常超出了 MBR 空间所能容纳的范围，因此必须采用多阶段设计，其中 MBR 部分只知道如何从其他位置加载下一阶段，我们现在先不着重讨论这一过程）。 在启动系统的过程中，BIOS 固件只能识别系统包含的磁盘。而作为 BIOS 计算机的拥有者，你可以告诉 BIOS 固件你想从哪个磁盘启动系统。而固件本身并不知道其他细节，它只会执行在指定磁盘的 MBR 部分所发现的启动装载程序，就这么回事。在执行启动装载程序之后，固件本身就不再参与启动。 在 BIOS 组合中，所有的多重启动形式都肯定是在固件层上进行处理的。固件层无法真正识别启动装载程序或操作系统，甚至连分区都无法识别。固件所能执行的操作只是从磁盘的 MBR 中运行启动装载程序。你无法从固件外部配置启动过程。 UEFI 启动：背景好，BIOS 组合的背景知识已经明确了。我们现在来看看 UEFI 计算机上的启动原理。即使未掌握本文的细节，也请记住这一点：UEFI 与 BIOS 完全不同。UEFI 启动原理与 BIOS 绝对不同。你不能把 BIOS 启动的原理直接套用到原生 UEFI 启动上。你不能把专为 BIOS 启动设计的工具应用到原生 UEFI 启动的系统上。记住，UEFI 组合完全不同。 还需要了解一个重点：许多 UEFI 固件实现了某种 BIOS 兼容模式（有时候称为 CSM）。许多 UEFI 固件可以像 BIOS 固件一样启动系统，它们可以查找磁盘上的 MBR，然后从 MBR 中执行启动装载程序，接着将后续工作完全交给启动装载程序。有时候，其他人误将此功能称为“禁用 UEFI”，从语言学角度而言，这种说法是荒谬的。系统固件是无法“禁用”的。这种说法很愚蠢，不要采用这种说法。但是在其他人这么说的时候，应该了解他们真正想表达什么。他们讨论的是通过 UEFI 固件的一项功能，以“BIOS 风格”启动系统，而不是采用原生 UEFI 方式启动系统。 我想解释一下原生 UEFI 启动。如果你有一台基于 UEFI 的计算机，其固件具有 BIOS 兼容功能，并且你打算一直使用这项兼容功能，在启动过程中，你的计算机看起来就是基于 BIOS 的。你只需要像 BIOS 启动一样进行所需操作即可。如果你确实有此打算，那么就不要中途变卦。对于你日常使用的操作系统，强烈建议不要混合使用原生 UEFI 启动和 BIOS 兼容启动，尤其不要在同一块磁盘上混用。这么做的话，你会痛不欲生。如果你决定混合使用原生 UEFI 启动和 BIOS 兼容启动，到时候就别找我哭诉。 为了理清头绪，我将假设磁盘采用 GPT，并且包含用于 EFI 的 FAT32 EFI 系统分区 (ESP)。根据你对这些知识的深入程度，你可能发现，在进行原生 UEFI 启动时，GPT 磁盘和 EFI FAT32 ESP 并不是必要条件。但是 UEFI 规范和 GPT 磁盘以及 EFI FAT32 ESP 的联系程度相当密切。在99%的情况下，你要处理的也正是这样的组合。除非你在使用 Mac（老实说，Mac 混乱不堪）。 编辑说明：以下章节（到缺陷为止）在 2014 年 1 月 26 日（本文发布的几小时后）根据 Peter Jones 的反馈进行了大量修订。本文可视为 v2.0 版本。早期版本的写作方式不够严谨，而且内容可能会产生误解。 UEFI 原生启动：实际工作原理——背景言归正传。本节将解释原生 UEFI 启动的实际工作原理。如果已掌握一定程度的背景知识，可能更容易深入理解本节内容。 在固件层，UEFI 的基础架构更丰富，可用于处理系统启动。UEFI 远不像BIOS 那么简单。与 BIOS 不同，UEFI 确实可以（不同程度上）理解“磁盘分区”、“启动装载程序”以及“操作系统”的概念。 你可以稍微看看 BIOS 启动过程，然后再看看 UEFI 启动过程，了解 UEFI 启动过程如何采用多种措施来解决特定问题。 在思考启动过程时，你会发现 BIOS/MBR 查找启动装载程序的方法实在不怎么样。BIOS/MBR 非常奇葩：位于磁盘起始位置的这一小段空间包含神奇代码 (magic code)，而这段神奇代码只作用于系统固件和写入此神奇代码的工具。这种方法有许多问题。 处理不便——你需要特殊工具来写入 MBR，如果要查看 MBR 中包含的内容，唯一的方法几乎就是把 MBR dd 出来，然后进行检查。 如上所述，MBR 本身不足以容纳许多现代启动装载程序。这些启动装载程序会将自身的一小部分安装在 MBR 中，而将其他部分安装到磁盘上的可用空间中。这段可用空间位于常规 MBR 末尾和第一个分区的起始位置之间。这就会造成很大的问题（其实这整个设计就是个大问题，不过无所谓）。对于第一个分区的起始位置，并没有成文的可靠规定，因此难以确保空间足够。只有一件事情是肯定的：这段空间不足以容纳某些启动装载程序的配置。 如果要选择其他启动目标（除磁盘以外），这种设计没有提供任何标准化层或标准化机制，但是用户希望选择除磁盘以外的启动目标。也就是说，他们希望实现多重可启动对象——通常是操作系统。在 BIOS/MBR 组合中，实现这种目的的唯一方法是由启动装载程序进行处理；至于如何实现，并没有进行获得广泛认可的规定。虽然实现的方法非常多，但是它们无法彼此协作，而且也都不是获得广泛认可的标准或规定。而在操作系统/操作系统安装层编写工具的难度很大，无法干净利落地处理多重启动。因此这种设计非常混乱。 这种设计没有提供标准方法，让用户可以从除磁盘以外的目标进行启动。本文不会就此问题进行详细讨论，但是请注意，UEFI 启动的另一优势为：它提供了进行启动（例如，从远程服务器进行启动）的标准方法。 固件层以上的其他层无法配置固件的启动行为，BIOS 没有提供相应机制。 可以想象，在 UEFI 设计之初，开发人员思考过这些问题，并最终提出解决方案。UEFI 固件并不仅仅可以识别磁盘，它也知道启动装载程序代码在每个磁盘上所处的位置，而且在固件层，UEFI 的基础架构更丰富，可用于处理启动装载。接下来，我们讨论下 UEFI 规范中定义的相关内容。 EFI 可执行文件UEFI 规范定义了一种可执行文件格式，并要求所有 UEFI 固件能够执行此格式的代码。当开发人员为原生 UEFI 编写启动装载程序时，就必须按照这种格式编写。这种设计非常简洁直观，也无需进一步解释：对于固件可以执行的代码，固件规范真正定义了其通用格式，这是件好事。 GPT（GUID 分区表）格式GUID 分区表格式与 UEFI 规范具有密切联系，而且，它并不特别复杂，无需多加解释。GPT 是 UEFI 规范提供的良好基础架构之一。GPT 仅仅是分区表的一种标准——磁盘起始位置的信息定义了磁盘所包含的分区。相比 MBR/MS-DOS 分区表，这种分区表对分区的定义要好得多，并且 UEFI 规范要求 UEFI 兼容固件必须能识别 GPT（也要求固件能识别 MBR，以保证向后兼容）。所有这些规范都是相当实用的基础架构： UEFI 规范正建立某些功能，固件层上的一切都可依靠固件本身来实现这些功能。 EFI 系统分区在修订本文时，我才真正思考 EFI 系统分区的概念，让我有如醍醐灌顶。实际上，“EFI 系统分区”的概念可以解决“奇葩”的 MBR 空间所产生的问题。在磁盘起始位置留出自由空间，用于存放启动装载程序代码，但又不定义其容量，这种设计糟糕透顶。这一点在上文已经讨论过了。EFI 系统分区是 UEFI 用于解决这种问题的解决方案。1 具体的解决方案如下：我们要求固件层能够读取某些特定的文件系统类型。UEFI 规范要求兼容固件必须能读取 FAT 格式的变种（包括 FAT12、FAT16 和 FAT32）。UEFI 规范实际扮演的角色就是编纂整理 FAT 文件系统格式的现有解释，确保在采用 UEFI 时可以使用那些格式，并规定 UEFI 兼容固件必须能够读取那些格式。UEFI 规范针对这方面的具体规定如下： “可扩展固件接口 (EFI) 支持的文件系统基于 FAT 文件系统。EFI 定义了可以明确记录和测试的具体 FAT 版本。FAT 的唯一定义必须符合 EFI 规范及关联参考文档，对 FAT 唯一定义的实现必须支持 EFI。为区分 EFI 文件系统与纯 FAT，定义了新的分区文件系统类型。” “EFI 系统分区”是采用 FAT 变种（UEFI 规范定义的变种之一）格式化的任意分区，该分区被赋予特定 GPT 分区类型，以帮助固件识别该分区。此分区的目的如上所述：固件层确实可以读取“普通”磁盘分区中的数据。希望我已明确解释为何这种设计更佳：操作系统可以创建、格式化和挂载分区（采用广泛理解的格式），并将启动装载程序的代码和固件可能需要读取的所有其他内容放到这个分区中，而不用像 MBR 磁盘一样，将启动装载程序的代码写入磁盘的起始位置空间。 刚开始的时候，对我而言，整个 ESP 的设计看起来有点匪夷所思且令人困惑，因此我希望本节可以解释为何 ESP 实际上是非常优秀的设计——真正匪夷所思和令人困惑的设计是 BIOS/MBR。若要从操作系统层写入某些内容，唯一的方法是将这些内容写入磁盘起始位置的某部分（但不知道是多少）空间，而并没有具体规定其中的具体实现。如果回过头再看，这种设计并不明智，且难以理解。 正如我们稍后会强调的那样，UEFI 规范试图采用更直观严格的方法——它很少禁止固件执行其他操作。UEFI 规范并不反对编写固件，用于执行以其他格式写成的代码、读取其他类型的分区表，以及读取用UEFI 变种文件系统（非 FAT）格式化的分区。但是 UEFI 兼容固件必须至少能够实现执行 EFI 可执行文件、读取 GPT 分区表、以及读取 ESP，因此如果你正编写操作系统或其他东西，并且想要在 UEFI 兼容固件上运行的话，你也得遵循 UEFI 规范，这就是 EFI 系统分区的概念非常重要的原因：它允许（至少理论上）将 EFI 可执行文件放在以 UEFI FAT 格式化且 GPT 分区类型正确无误的分区上，另外，系统固件要能够读取该分区。这种机制非常严谨，等价于 BIOS 中的“固件能够执行放置在 MBR 空间中的启动装载程序代码”。 UEFI 规范UEFI 规范为我们提供了三大重要基础，这些重要基础是上层架构正常运行的立足之本： 读取分区表 访问某些特定文件系统中的文件 执行特定格式的代码 相比 BIOS 固件所提供的功能，UEFI 的功能要丰富得多。但是，为了完成固件层可以处理多重目标（而不仅仅是磁盘）启动的愿景，我们需要其他基础：需要建立一种机制，通过这种机制，固件可以查找各种可能的启动目标，并提供相应的配置方法。 UEFI 启动管理器UEFI 规范定义了名为 UEFI 启动管理器的一项功能（Linux发行版包含名为efibootmgr 的工具，可用于更改 UEFI 启动管理器的配置）。如果你确实阅读过 UEFI 规范，那么就会发现，UEFI 规范对 UEFI 启动管理器作出了如下规定： “UEFI 启动管理器是一种固件策略引擎，可通过修改固件架构中定义的全局NVRAM 变量来进行配置。启动管理器将尝试按全局 NVRAM 变量定义的顺序依次加载 UEFI 驱动和 UEFI 应用程序（包括 UEFI 操作系统启动装载程序）。” 好，既然已经明确了这一概念，那我们就继续吧。不，先等等。我来先把那一项规定解释清楚，便于理解。简单来说，你可以把 UEFI 启动管理器视为启动菜单。在 BIOS 固件上，固件层的“启动菜单”（当然）是，启动时连接到计算机的各个磁盘——不多不少。但是对于 UEFI 固件而言，情况有所不同。 UEFI 启动管理器可以进行配置——简言之，你可以向“启动菜单”添加项或者从中删除项。固件也可以（事实上， UEFI 规范也有此要求）根据连接到计算机的磁盘或根据某些固件配置，在此启动菜单中“生成”有效项。你也可以检查启动菜单，确保正确无误。 UEFI 提供了一种非常优秀的机制，可以从上层架构执行此操作：你可以从已启动的操作系统中配置系统启动行为。如果已通过 UEFI 启动 Linux，就可以使用 efibootmgr 工具来完成所有这些操作。Windows 也有相应的工具，但是我对 Windows 下的工具非常不熟悉。我们不妨看一些典型的 efibootmgr 输出，这些是我从 Fedora 论坛转过来的，稍微进行了调整： [root@system directory]# efibootmgr -vBootCurrent: 0002Timeout: 3 secondsBootOrder: 0003,0002,0000,0004Boot0000 CD/DVD Drive BIOS(3,0,00)Boot0001 Hard Drive HD(2,0,00)Boot0002 Fedora HD(1,800,61800,6d98f360-cb3e-4727-8fed-5ce0c040365d)File(\\EFI\\fedora\\grubx64.efi)Boot0003 opensuse HD(1,800,61800,6d98f360-cb3e-4727-8fed-5ce0c040365d)File(\\EFI\\opensuse\\grubx64.efi)Boot0004* Hard Drive BIOS(2,0,00)P0: ST1500DM003-9YN16G .[root@system directory]# 这个示例非常清晰。我们可以从中观察细节。 第一行表示，目前你从“启动菜单”的哪个项进行了启动。第二行非常明显（如果固件的 UEFI 启动管理器显示了类似启动菜单的界面，那么这一行表示继续启动默认项之前的超时）。BootOrder 是列表中启动项的尝试顺序。其余输出显示了实际的启动项。我们稍后会说明每一个启动项具体作用。 如果完全正常启动 UEFI 固件，而不进行任何调整（我们稍后会讨论），UEFI 固件将按照BootOrder 中列出的顺序，尝试从“启动菜单”中的每个“项”进行启动。因此，在这台计算机上，UEFI 固件将尝试启动名为“opensuse”的项，如果启动失败，然后再尝试启动名为“Fedora”的项，然后再是“CD/DVD Drive”，接着是第二项“Hard Drive”。 UEFI原生启动：实际工作原理——启动管理器项那么，这些项的实际含义是什么？实际上，UEFI 规范之所以显得复杂，很大程度上是因为其中的不确定因素太多。如果你正在阅读 UEFI 规范，那么先做好心理准备，然后前往 EFI_DEVICE_PATH_PROTOCOL 一节。但是请注意，这个协议是通用的，虽然这个协议不涉及启动过程，但是有其他作用——这实际上就是 UEFI 官方的设备标识方法，这种标识方法可用于启动管理器项以及各种其他用途。出于各种原因，并不是每一种潜在的 EFI 设备都像 UEFI 启动管理器项一样起作用（如果你想从视频适配器启动，很可能不会成功）。但是启动菜单中显然可以包含指向 PXE 服务器（而不是磁盘分区）的项。UEFI 规范进行了多项规定，可以向 UEFI 启动管理器配置中添加除磁盘以外的启动目标。 但是对我们而言，只需要考虑连接到计算机的一般磁盘即可。既然这样，我们来讨论下可能遇到的三种启动项类型。 BIOS 兼容启动项在本示例中，Boot0000 和 Boot0004 实际上是 BIOS 兼容模式启动项，而不是原生 UEFI 启动项。这些启动项不是通过外部工具添加到 UEFI 启动管理器配置中的，而是由固件本身生成的——这也是 UEFI 固件实现 BIOS 兼容启动的常见方式，通过生成 UEFI 启动管理器项，可触发指定设备的 BIOS 启动。至于 UEFI 启动管理器如何呈现给用户，这是另一个问题，我们稍后讨论。根据具体固件及其配置，其中有些项可能无法显示。每一项只会具有一个名称（“CD/DVD Drive”、“Hard Drive”），这表示“如果选中此项，那么就以 BIOS 兼容模式启动本磁盘”（其中，对于 Boot0000，“本磁盘”为 3,0,00，对于 Boot0004，“本磁盘”为 2,0,00）。 “回退路径 (Fallback path)”UEFI 原生启动项Boot0001 项（我虚构的，实际操作中可能不存在，这里只是为了举例说明）用于通知固件尝试从特定磁盘启动（以 UEFI 模式而不是 BIOS 兼容模式），但是并没有向固件提供其他信息。它没有指定磁盘上的具体启动目标，而只是让固件启动磁盘。 UEFI 规范定义了一种“回退”路径 (Fallback path)，用于启动此类启动管理器项，其工作原理类似于 BIOS 驱动器启动：它会在标准位置查找某些启动装载程序代码。但是其中的细节和 BIOS 不同。 当尝试以这种方式启动时，固件真正执行的操作相当简单。固件会遍历磁盘上的每个 EFI 系统分区（按照磁盘上的分区顺序）。在 ESP 内，固件将查找位于特定位置的具有特定名称的文件。在 x86-64 PC 上，固件会查找文件 \\EFI\\BOOT\\BOOTx64.EFI。固件实际查找的是 \\EFI\\BOOT\\BOOT{计算机类型简称}.EFI，其中，“x64”是 x86-64 PC 的“计算机类型简称”。文件名还有可能是 BOOTIA32.EFI (x86-32)、BOOTIA64.EFI (Itanium)、BOOTARM.EFI（AArch32，即32位ARM）和 BOOTAA64.EFI（AArch64，即64位ARM）。然后，固件将执行找到的第一个有效文件（当然，文件需要符合UEFI规范中定义的可执行格式）。 这种机制的设计目的不在于启动日常使用的操作系统。它的设计目的更像是为了启动可热插拔、与设备无关的介质（如 Live 映像和操作系统介质）。这也是这种机制的常见用途。如果查看 Linux 或其他操作系统的 UEFI 兼容 Live 或安装介质，你会发现其中包含 GPT，以及位于（或靠近）设备起始位置的 FAT 分区，该分区的 GPT 分区类型标识为 EFI 系统分区。在那个分区中，会有一个 \\EFI\\BOOT 目录，目录中至少包含上述特殊命名的文件之一。当以原生 UEFI 模式启动 Fedora Live 或安装介质时，就会采用这种机制。BOOTx64.EFI（或其他）文件将处理剩余启动过程，从而启动介质上包含的真正操作系统。 完全原生 UEFI 启动项Boot0002 和 Boot0003 是存储设备上所安装操作系统的“典型”项。这些项显示了 UEFI 启动机制的全部优势，不仅仅是“从此磁盘启动”，而是“启动此特定磁盘上此特定位置中的这一特定启动装载程序”。 Boot0002 是由原生 UEFI Fedora 安装生成的启动项。Boot0003 是由原生 UEFI OpenSUSE安装生成的启动项。按照字面意思，这些启动项表示“从此分区加载这一文件”。分区指的是 HD(1,800,61800,6d98f360-cb3e-4727-8fed-5ce0c040365d) 这个东西：表示某一特定分区（使用 EFI_DEVICE_PATH_PROTOCOL，我不打算对此进行详细介绍。如果你通过固件界面和 efibootmgr 与启动管理器进行交互，你也不需要知道其中的细节）。文件指的是 (\\EFI\\opensuse\\grubx64.efi) 这个东西：它仅表示“加载所述分区上此位置中的文件”。这里所指的分区基本上始终指的就是充当 EFI 系统分区的那个分区，因此：可以放心地让固件访问 EFI 系统分区。 UEFI 规范提供这一机制，以便操作系统可启动：操作系统将启动装载程序（作用为加载操作系统内核等）安装到 EFI 系统分区中，并使用某一名称（显然，这一名称通常来源于操作系统名称）以及启动装载程序（EFI 可执行格式，用于加载操作系统）的位置向 UEFI 启动管理器配置中添加启动项。 Linux发行版使用 efibootmgr 工具处理 UEFI 启动管理器。进行原生 UEFI 安装时，有关启动装载方面，Linux 发行版实际进行的操作相当简单：它会创建一个 EFI 系统分区（如果不存在此分区），使用相应配置将 EFI 启动装载程序（通常为 grub2-efi，但是也有例外）安装到 EFI 系统分区中的正确路径下，然后调用 efibootmgr 添加相应的 UEFI 启动管理器项（指向其启动装载程序）。如果已存在 EFI 系统分区，大部分发行版会使用现有分区（尽管完全可以创建新的 EFI 系统分区并使用这个新分区）：我们已经提到过，UEFI 是一种宽松规范，只要在逻辑上遵循其设计，那么有多少个 EFI 系统分区都没问题。 配置启动过程（固件 UI）上文描述了 UEFI 规范定义的基本机制，用于管理 UEFI 启动过程。固件用户界面可能不会明确遵循这一机制，了解这一点非常重要。不幸的是，UEFI 规范有意未限制启动过程的呈现方式或用户配置启动过程的方式，这表示——由于我们也从事固件工程——每个固件会有不同的实现方法，并且其中某些固件的实现方法较疯狂。 许多固件的启动配置界面较直观。优秀的固件设计至少会显示启动顺序以及其中的各个启动项，允许用户添加/删除项、更改启动顺序或在某次特定启动中忽略原有启动顺序（仅针对那次启动生效，或直接让固件启动特定菜单项，甚至可以选择让固件以 BIOS 兼容模式或 UEFI“回退 (Fallback)”模式“启动这块磁盘”，我的固件就可以这么操作）。此类界面通常可以仅按名称显示完整的原生 UEFI 启动项（例如我们上文提到的 Fedora 和 OpenSUSE 示例）；你需要检查 efibootmgr –v 的输出，以详细了解在调用这些项时，它们具体会尝试并执行哪些操作。 某些固件会尝试对配置进行抽象和简化，最终结果良莠不齐。例如，如果可以选择“启用或禁用”BIOS 兼容模式，固件很有可能会为已连接驱动器的 UEFI 启动管理器配置添加或删除 BIOS 兼容项。如果可以选择“启用或禁用”原生 UEFI 启动，那么在用户“禁用”原生 UEFI 启动时，固件很有可能更改 UEFI 启动管理器配置，从 BootOrder 中删除所有原生UEFI启动项。 请谨记，固件界面中的所有配置选项所执行的操作就是在后台配置 UEFI 启动管理器的行为。如果你能理解以上所有内容，那么当你更改固件界面中的选项时，你会更容易理解其背后的本质。 在 BIOS 中，系统不会始终尝试优先从可移动驱动器（CD、USB）进行启动，然后再从驱动器启动。根据实际情况，结果可能有所不同。有些 BIOS 固件会优先尝试从 CD 启动，然后再尝试从硬盘启动（而不是 USB）。试图安装新的操作系统时，用户已习惯于时常检查 BIOS 配置，以确保启动顺序“正确无误”。 UEFI 也是如此，但是由于 UEFI 启动管理器机制的灵活性/复杂性，这一过程看起来可能显得陌生而可怕。 在系统尝试启动固定启动项之前，如果想要确保系统使用“回退(Fallback)”机制优先从可移动设备启动（例如，在安装 Fedora 时），需要将可移动设备作为固件的默认启动项，或需要相应设置固件。根据具体固件界面，可能发现每个连接的可移动设备都有对应的“菜单项”，你只需要调整启动顺序，把你想要的可移动设备放在首位即可，有时候你也会发现可以直接请求“对此特定磁盘进行 UEFI 恢复启动”，另外你还可能发现固件会尝试将配置进行抽象。我们不知道具体的固件界面是什么样，因此难以编写说明。但是既然你已了解背后的工作原理，那么就可能更容易理解固件用户界面配置的含义。 配置启动过程（通过操作系统）如上所述，与 BIOS 机制不同，你可以从操作系统层面配置 UEFI 启动过程。如果你的固件比较令人恶心，你可能需要执行此操作才能达成目的。 你可以使用之前提过的 efibootmgr 工具来添加、删除和修改 UEFI 启动管理器配置中的项，这一工具也具有其他丰富功能。你可以更改启动顺序。你可以更改下次启动时的首要启动项，而不需要使用 BootOrder 列表（如果你或其他某些工具已经进行过配置，efibootmgr –v 的输出将包括 BootNext 项，说明下一次启动将加载的菜单项）。Windows 下也有类似的工具。因此如果你难以从固件界面配置 UEFI 启动，但是你可以启动某种原生 UEFI 操作系统，那么你可以考虑从操作系统（而不是固件 UI）进行启动配置。 结论： UEFI固件包含某些非常类似于启动菜单的内容。 可以使用 efibootmgr –v 从任何原生 UEFI 启动的 Linux 操作系统中查询 UEFI 启动配置，也可以使用 efibootmgr 更改配置（有关详细信息，请参阅 man 页面）。 “启动菜单”可以包含表示“以 BIOS 兼容模式启动此磁盘”，“通过回退路径 (Fallback path) 以原生 UEFI 模式启动此磁盘”（将使用上文所述的“寻找 BOOT(某字符串).EFI”方式），或“启动此特定位置（几乎始终为 EFI 系统分区）中的特定 EFI 格式的可执行文件”等含义的项。 UEFI 规范尝试一种优秀、简洁的设计，让所有操作系统都将其自身的启动装载程序安装到 EFI 系统分区中，然后在“启动菜单”中添加指向这些启动装载程序的项，同时不得干涉其他目标的启动过程。 你的固件 UI 可以自由实现此机制，虽然具体的实现结果良莠不齐。 在 UEFI 计算机上安装操作系统 我们快速浏览下上文中与在 UEFI 计算机上安装操作系统相关的具体结果。 原生 UEFI 启动和 BIOS 兼容启动 用户有时会忽略以下事项： 如果以“原生 UEFI”模式启动安装介质，安装介质将以原生 UEFI 模式安装操作系统：它将尝试向 EFI 系统分区写入 EFI 格式的启动装载程序，并尝试向 UEFI 启动管理器的“启动菜单”中添加启动项，用于启动该启动装载程序。 如果以“BIOS 兼容”模式启动安装介质，安装介质将以 BIOS 兼容模式安装操作系统：它将尝试向磁盘上的 MBR 空间写入 MBR 类型的启动装载程序。 这适用于（现在暂时忽略其中的无关警告）我接触过的所有操作系统。因此你可能确实想了解，如何在固件层选择以原生 UEFI 模式启动可移动设备，以及如何在固件层选择以 BIOS 兼容模式启动可移动设备，确保在安装时可以随意选择需要使用的模式。 如果以 BIOS 兼容模式启动安装介质，那么你绝对无法成功进行操作系统的原生 UEFI 安装，因为安装程序无法配置 UEFI 启动管理器（除非以原生 UEFI 模式启动安装介质）。 理论上，在以原生 UEFI 模式启动之后，操作系统的安装程序可通过 BIOS 模式安装该操作系统，即，将启动装载程序写入磁盘 MBR，但是大部分安装程序无法执行此操作，这种做法比较可取。 确定启动模式有时候，在启动操作系统安装程序之后，你不确定启动模式为原生 UEFI 模式还是 BIOS 兼容模式。别担心。有几种简单方法可以确定启动模式。最简单的方法之一是尝试读取 UEFI 启动管理器。如果你启动了 Linux 安装程序或环境，并且可以运行 shell（例如，在 Fedora 安装程序中是 Ctrl-Alt-F2），请运行 efibootmgr –v。如果你启动的是原生 UEFI 模式，那么就可以看到上文所示的 UEFI启动管理器配置。如果你启动的是 BIOS 兼容模式，那么会看到类似以下内容： Fatal: Couldn’t open either sysfs or procfs directories for accessing EFI variables.Try ‘modprobe efivars’ as root. 如果启动了其他操作系统，你可以尝试运行该操作系统的内置实用程序，读取 UEFI 启动管理器，并查看是否显示了明确输出或类似错误。或者你可以检查系统日志并搜索“efi”和/或“uefi”，从中可能发现蛛丝马迹。 启用原生 UEFI 启动若要启用原生 UEFI 模式的启动，那么操作系统安装介质必须明确符合我们刚刚说明的所有规范：具有 GUID 分区表，和 EFI 系统分区，启动装载程序位于正确的“回退”路径 (Fallback path) 中—\\EFI\\BOOT\\BOOTx64.EFI（其他平台可能会有其他名称）。如果无法以原生 UEFI 模式启动安装介质，并且无法查出原因，那么请检查安装介质是否满足上述条件。显然，当使用 livecd-iso-to-disk 工具将 Fedora 映像写入 USB 存储器时，你必须传递 –efi 参数，才能将存储器配置为可用 UEFI 模式启动。 强制使用 BIOS 兼容启动如果你的固件难以通过 BIOS 兼容模式从可移动介质启动，但是你又确实想通过这种方式启动，那么可以使用一些小把戏：完全禁用该介质的原生 UEFI 启动模式。可以通过清除所有 EFI 系统分区来轻松执行此操作（或者，如果使用 livecd-iso-to-disk 从 Fedora 映像创建 USB存储器，那么只需去掉 –efi 参数，存储器就会变为不可通过 UEFI 模式启动）。如果执行完此操作以后，你的固件仍然无法以 BIOS 兼容模式启动介质，那么就去吐槽你的固件供应商吧（如果还没吐槽过）。 磁盘格式（MBR vs. GPT） 其他注意事项如下： 如果想执行“BIOS 兼容”类型的安装，那么需要安装到 MBR 格式的磁盘。 如果想执行原生 UEFI 安装，那么需要安装到 GPT 格式的磁盘。 当然，为了给用户找不自在，许多固件可以通过 BIOS 模式从 GPT 格式的磁盘启动。事实上，从技术层面而言，也要求 UEFI 固件能从 MBR 格式的磁盘以 UEFI 模式启动（虽然无法保证）。但是你应当尽可能避免这种情况。这些注意事项非常重要，因为许多用户都曾深受其害。例如，以原生 UEFI 模式启动操作系统安装程序，然后试图直接安装到 MBR 格式的磁盘是非常不明智的。很有可能失败。多数现代操作系统安装程序将把磁盘自动重新格式化为正确格式（如果你允许安装程序彻底清除磁盘数据），但是，如果你尝试让安装程序“对此 MBR 格式的磁盘执行原生 UEFI 安装，并且不要重新格式化这块磁盘，因为上面有重要数据”，那么就很有可能失败，尽管技术层面而言，UEFI 规范提到了这种配置。具体而言，至少 Windows 和 Fedora 会明确禁止这种配置。 检查磁盘格式你可以使用 parted 实用程序检查给定磁盘的格式： [adamw@adam Downloads]$ sudo parted /dev/sdaGNU Parted 3.1Using /dev/sdaWelcome to GNU Parted! Type ‘help’ to view a list of commands.(parted) pModel: ATA C300-CTFDDAC128M (scsi)Disk /dev/sda: 128GBSector size (logical/physical): 512B/512BPartition Table: msdosDisk Flags: Number Start End Size Type File system Flags1 1049kB 525MB 524MB primary ext4 boot2 525MB 128GB 128GB primary lvm (parted) 注意到 Partition table: msdos 那一行了吗？这是一块 MBR/MS-DOS 格式的磁盘。如果是 GPT 格式的磁盘，会显示 gpt。你可以从 parted 中通过执行 mklabel gpt 或 mklabel msdos 将磁盘重新格式化为其他类型分区表。这会破坏磁盘内容。 对于多数操作系统的安装程序而言，如果你采用的磁盘配置会清空目标磁盘的所有内容，那么根据执行的安装类型，安装程序就会自动使用最合适的配置重新格式化磁盘。但是如果你想使用现有磁盘而不格式化，那么你需要检查该磁盘的格式并三思而后行。 执行手动分区时处理 EFI 系统分区我只能针对 Fedora 给出权威建议，但是其中的主要内容可能也适用于其他发行版/操作系统。 执行原生 UEFI 安装，并且采用 GPT 格式的磁盘时，或者允许 Fedora 重新格式化磁盘（通过删除所有现有分区）时，如果允许 Fedora 自动处理分区，那么 Fedora 就会自动处理 EFI 系统分区。 但是，如果使用自定义分区，Fedora 会要求指定 EFI 系统分区，以供安装程序使用。如果不执行此步骤，安装程序会报错（错误消息的含义不明）并拒绝启动安装。 因此，如果执行原生 UEFI 安装并使用自定义分区，需要确保类型为“EFI 系统分区”的分区已挂载到 /boot/efi（这是 Fedora 查找 EFI 系统分区的路径）。如果系统上存在现有 EFI 系统分区，那么仅需将其挂载点设置为 /boot/efi 即可。如果还没有 EFI 系统分区，那么请创建一个分区，将其类型设置为 EFI 系统分区，大小至少为 200MB（建议 500MB），然后将其挂载点设置为 /boot/efi。 具体示例总结：如果购买了 Windows 8 或更高版本的操作系统，那么你的 Windows 基本上肯定是通过原生 UEFI 安装到 GPT 格式磁盘的。这表示如果你想安装其他操作系统，并与 Windows 共存，那么需要通过原生 UEFI 方式安装操作系统。如果你不喜欢 UEFI，并且想要用回老掉牙的 BIOS，那么恐怕就得清空整个原生 UEFI 的 Windows，而且需要重新将磁盘格式化为 MBR。 缺陷上文解释了 UEFI 的启动原理(至少解释得差不多了)。我这种描述方法应该还可以吧？ 但是，UEFI 并不完美，也有许多问题。 细心的读者可能已经留意，我曾经提到过，UEFI 规范提供了一种机制。这种说法很严谨，也很重要。由于 UEFI 规范是一种“广泛共识”，因此其主要缺点之一（就特定方面而言）是并未提供具体实现。 如果仔细阅读 UEFI 规范，就会发现 UEFI 规范的基本方式是定义 UEFI 兼容固件必须支持的一系列功能。但是 UEFI 规范并没有严格规定这些功能的具体实现方法。 因此，UEFI 规范只要求系统固件必须遵循其中描述的所有内容，以便满足 UEFI 兼容固件的要求。但是，规范本身未规定操作系统“应该”或“必须”怎么做，并且 UEFI 规范也没有规定固件不得支持（或者不期望支持）的功能。换言之，在制定 UEFI 固件时，需要支持 GPT 格式的磁盘和 FAT 格式的 EFI 系统分区，并且必须以标准格式读取 UEFI 启动管理器项等等——但是也可以随意添加其他未规定的功能。 从 UEFI 规范中不难发现其中的隐喻——UEFI 规范仔细设置了一种良好机制，用于在固件层处理操作系统（或其他启动项）选择。但是 UEFI 规范并不要求一定要这么做，其他广受赞誉的规范也没有类似规定。 因此，在实际使用时，我们可能遇到各种复杂情况。例如，Apple Mac 的 HFS+ 分区中随附了某些启动装载程序。UEFI 规范提到，UEFI 兼容固件必须支持特定 GPT 分区类型的 UEFI FAT 分区（标识为“EFI 系统分区”），但是 UEFI 规范并没有提到固件不能识别其他文件系统类型并从中加载启动装载程序。（此类分区是否应视为“EFI 系统分区”，这很难回答，在此不做探讨。） 要是所有厂商都能按照 UEFI 规范严格使用 EFI 系统分区，那就不会有这么多问题了。但是 Apple 毕竟是 Apple，它的产品设计领先于其他厂商，率先设计出了可以从 HFS+ 分区读取和加载代码的固件，导致现在其他厂商不得不紧随 Apple 的脚步，除非他们不打算支持 Mac。在启动过程设计中，Apple 进行的工作远超出 UEFI 规范的范围，因此，如果你想让其他操作系统以美观的图标或其他形式显示在 Mac 的图形启动菜单上，你所要做的操作将超出 UEFI 规范的建议范围。 还有各种类似的极端状况，使人烦不胜烦，但是我们先不管了。这篇文章够长的了。 另外，就像之前提到过的，UEFI 规范并没有对机制的具体呈现方式进行约束。因此，如果一些软件公司设计的操作系统符合 UEFI 规范，并且可以安装 EFI 启动装载程序，并明确命名 EFI 启动管理器项（例如，Fedora 和 Windows），那么如果要向用户提供某种相对辨识度较高的漂亮界面，让用户可以从中选择启动 Windows 或 Fedora，就得看固件本身设计得怎么样。固件设计得越糟糕，操作系统工程师就越不会遵守 UEFI 规范，他们越可能在固件层上另起炉灶。 说句公道话，我们可以在操作系统层实现更多功能。我们可以用更整洁直观的方式实现 efibootmgr 的所有功能——例如，我们可以采用“无视下一次启动时的启动顺序，直接启动此项”，同时将“重新启动到 Windows”作为选项之一。如果开发人员能够用更直观的方式展现 efibootmgr 的所有功能，那将会非常不错。Windows 8 系统在一定程度上采用了这种方式——例如，用户可以从 Windows 8 设置菜单中将系统重新启动到固件 UI。但是这还不够。 这些实在令人欲哭无泪，因为 UEFI 本来可以更好地进行统一。对于多重启动，BIOS 不提供任何类型的规范或标准，因此完全需要在固件层上处理多重启动。我们（这一行业）已经提出了某种处理多重启动的规范，但是我们从未将其付诸实施，因此最终不了了之。而每种操作系统都采用自己的多重启动方法，大量开发人员也自己写了启动装载程序，试图包揽所有操作系统。而所有操作系统和独立的启动装载程序难以互相兼容。我想说的是，在 UEFI 诞生之前，多重启动的实现方式一团混乱。 如果 UEFI——或者基于 UEFI 的某种规范——要求所有厂商遵循 UEFI 提出的规范，并要求固件提供直观的用户界面，那将会终结现阶段的混乱情况。但是现实不如人意，因此 UEFI 的情况完全可能比 BIOS 更糟糕。如果大量固件没有为 UEFI 启动管理器机制提供良好的 UI，那么操作系统供应商可能放弃 UEFI 启动管理器机制（或选择性地进行支持），转而在 UEFI 中重现 BIOS 多重启动的混乱情况——如此一来，我们就得收拾所有烂摊子，外加 UEFI 启动管理器层的其他影响。在整个 UEFI 启动管理器机制上，用户可能装有多个启动装载程序，互相争抢装载多个操作系统的控制权，而 UEFI 启动管理器机制只会机械地处理各种变量，而无法解决这种混乱情况。 这不是某人灵光闪现的荒唐想法，而是可能实际发生的真实情形。 另外，在这方面产生的 UEFI 缺陷是由一时疏忽引起的——这些缺陷不受委员会控制，也不是某人故意为之的结果。如果你的系统固件很坑爹，无法让你轻松访问 UEFI 启动管理器，那么你的发泄对象不应该是 UEFI 论坛或微软，当然也不是 Fedora 或者我。你应该归咎于系统/主板制造商和他们雇用的傻逼固件开发人员。凡是大脑健全的人，都能看出来，UEFI 规范已经明确说明，为 UEFI 启动管理器提供某种直观的用户界面是非常有益的，所有反人类的固件都是一堆垃圾代码。的确，UEFI 论坛已经意识到固件工程师难以脱离现有约束重新学习新规范，但是，固件工程师最终还是应该与时俱进。 简单来说，“所有固件都是垃圾代码”。这句话通常非常准确。 安全启动 (Secure Boot)我们最后要介绍的，就是安全启动 (Secure Boot)。 安全启动 (Secure Boot) 并不神奇，也不复杂。才怪。安全启动 (Secure Boot) 复杂得要命，但是其理论并不复杂。安全启动 (Secure Boot) 本身也并不邪恶。事实就是如此，你也应当认同这一事实，除非你认为GPG也有恶意。 在 UEFI 规范（2.4A 版本）的第 28 章对安全启动 (Secure Boot) 进行了定义。这种机制事实上非常明智。但是其原理却非常简单。UEFI 规范规定固件可以包含一系列签名，并拒绝运行未签名或签名与固件中包含的签名不一致的 EFI 可执行文件。 就这么简单?当然不是了，这只是一种简单概括。安全问题很复杂，因此才会产生通过安全启动 (Secure Boot) 来实现真正安全启动链的各种方法。mjg59 可以进行详细介绍，或者你可以完整阅读第 28 章。但是其中只涉及了基本概念。 使用公开密钥加密来验证某个文件完整性的方法很难判断其好坏。几乎所有 Linux 发行版都依赖这种加密方法——我们为软件包签名，在尝试安装未使用我们的密钥之一签名的软件包时，软件包管理器将发出警告。这不是我们的错，我也不认为会有人因为以这种方式使用公开密钥加密进行签名而归咎于操作系统本身。从字面上看，安全启动 (Secure Boot) 与这种广泛认可的机制完全相同，只不过安全启动 (Secure Boot) 适用于启动链。由于一撮媒体人找错了槽点，并揪着不放，导致大众受到了广泛误导，认为安全启动 (Secure Boot) 是洪水猛兽。 UEFI 规范中定义的安全启动 (Secure Boot) 并没有对固件所信任的密钥形式及其来源作出规定，我也不打算介绍所有细节，因为过于枯燥乏味，而且本文已经挺长了。但是总的来说，UEFI 规范只对执行启动链的加密验证进行了定义。UEFI 规范甚至没有涉及用于执行这一过程的策略可能产生的问题。这本来并没有错，因为这样可以保证其灵活性，并且 UEFI 规范允许在多个层面配置涉及的所有机制。UEFI 规范中未提及微软，也没有和微软互相勾结。如果你不信，那么你可以阅读 UEFI 规范。我已经提供了所有说明。字面上来说，对于那些反对在固件规范中将启动装载程序加密验证机制作为可选功能的人，我不予置评。 实际使用安全启动 (Secure Boot)有关安全启动 (Secure Boot) 的所有不满并不针对安全启动 (Secure Boot) 机制本身——虽然发出这些不满的人可能不这么认为——而是针对安全启动 (Secure Boot) 在实际操作中的特定实现方式。 我们唯一在意的是，对于预装 Windows 8 或更高版本 Windows 的 PC 而言，安全启动 (Secure Boot) 是默认开启的。 微软将这些称为“Windows 硬件认证要求”。这些要求并不是什么绝密内容，所有人都可以在互联网上阅读。 如果想从微软那里以低廉的价格获得预装 Windows 的批量许可，并在机箱上贴有“微软认证”标签，那么你必须符合这些认证要求。微软的约束力有限：他们不是美国或其他国家/地区的法律制定者，无论其他人怎么想。即使你销售的 PC 不符合这些要求，比尔•盖茨也不会拿你怎么样，前提是你不需要预装廉价的 Windows 副本和那张“微软认证”标签。对于不符合微软许可计划的在售 PC，事实上并不要求如何配置安全启动 (Secure Boot)，甚至根本不需要提供安全启动 (Secure Boot) 功能。具有 UEFI 2.2 或更高版本兼容固件的 PC 必须提供安全启动 (Secure Boot) 功能，但是并没有规定具体的实现方法（包括关闭安全启动 (Secure Boot) 的方法）。 如果你对安全启动 (Secure Boot) 意见很大，那么就别找借口了，马上去读读微软认证要求吧。你可以搜索“Secure Boot”来阅读相关内容。从“System.Fundamentals.Firmware.UEFISecureBoot”一节开始。 你最好读一遍，但是我对其内容进行了总结。 符合微软认证要求的计算机必须满足以下条件： 默认启用安全启动 (Secure Boot)（服务器除外） 在其信任密钥列表中包含微软的密钥 启用安全启动 (Secure Boot) 时，必须禁用 BIOS 兼容模式（如果没记错的话，UEFI 规范也有此要求） 支持签名黑名单 符合微软认证要求的 x86 计算机还必须满足以下附加条件： 允许自然人禁用安全启动 (Secure Boot) 允许自然人启用自定义模式，以及修改固件的信任密钥列表 符合微软认证要求的 ARM 计算机还必须满足以下附加条件： 不允许自然人禁用安全启动 (Secure Boot) 不允许自然人启用自定义模式，以及修改固件的信任密钥列表 是的，你没看错。对于 x86 计算机，微软认证要求明确规定了自然人用户应当能够完全控制安全启动 (Secure Boot)（启用或禁用），或完全控制安全启动 (Secure Boot) 的信任密钥列表。另一个重点是，尽管认证要求规定，信任密钥列表必须包括微软的密钥，但是其中没有规定不允许包括其他密钥。微软认证要求也明确允许系统包含其他任意数量的信任密钥。 这些要求并不完全出于微软的好意，之所以作出这些规定，是因为如果不这么做的话，微软将面临大量诉讼2。真正了解 UEFI 和安全启动 (Secure Boot) 的用户可能不会曲解微软认证要求，这些要求非常清晰明确。这些要求旨在确保认证系统的所有者能完全控制安全启动 (Secure Boot)，事实上这些要求也确实成功确保了这一条件。 如果你有包含 Windows 认证的 x86 系统，但是不允许你禁用安全启动 (Secure Boot)，那么这就直接违反了认证要求，你应该马上投诉。如果市面上存在大量这类系统，那么我们肯定会有麻烦，可能要给那些巨头厂商提起诉讼了。但是目前为止，事实并非如此。在我见过的所有 x86 Windows 认证系统中，其固件都有“禁用安全启动 (Secure Boot)”选项。 对于 ARM 计算机，认证要求显然更变态：其中的规定和 x86 完全相反，不允许禁用安全启动 (Secure Boot)，也不允许系统所有者更改信任密钥。非常糟糕且不合理。这使得微软认证 ARM 系统成为了一个封闭的环境。值得注意的是，其他主要 ARM 平台甚至更糟糕。Apple 在所有 iDevice 上锁定了启动装载程序，而且大部分 Android 设备的启动装载程序也是锁定的。 如果你计划购买微软认证 ARM 设备，请注意这一问题，你将无法控制设备上的启动项。如果你对此反感，那就不要购买这样的设备，也不要购买 iDevice 或启动装载程序处于锁定状态的 Android 设备（你可以购买启动装载程序未锁定或无法锁定的 Android 设备，但是需要事先进行调查研究）。 目前，就 x86 设备本身而言，微软的认证要求实际上明确保障了用户自由启动系统的权利。这是件好事。 建议以下内容是我在管理系统启动方面的一般建议，不保证其准确性、可靠性或安全性。 如果可以的话，每台计算机只安装一个操作系统。如果你需要一个以上操作系统，那就多买几台计算机，或使用虚拟机。这么做的话，事情就简单多了，而且无论你的固件是 BIOS 或 UEFI，或在 UEFI 系统上使用 BIOS 兼容启动，都没什么关系了。你在使用计算机时也会轻松许多。 如果你确实需要在每台计算机上安装多个操作系统，那么请在每块磁盘上至少安装一个操作系统。如果你比较熟悉 BIOS 启动，而且也不需要安全启动 (Secure Boot) 功能，在这种情况下，对于 UEFI 系统，请优先使用 BIOS 兼容启动。这样一来，可能不会有那么多麻烦，也不会造成数据丢失。如果每块磁盘只安装一个操作系统，那么你也可以混合使用原生 UEFI 和 BIOS 兼容模式。 如果你坚持要在每块磁盘上安装多个操作系统，那么请先理解本文所写内容。这么做无异于自作孽，不可活，出了问题可别责怪操作系统供应商。另外，在这种情况下，也不要混用原生 UEFI 和 BIOS 兼容模式，否则就是雪上加霜。 如果你在使用 UEFI 原生启动，并且不打算自己编译内核/内核模块或在 Linux 上使用 NVIDIA/ATI 私有驱动程序，那么最好启用安全启动 (Secure Boot)。这不会有什么副作用，反而可以带来额外的安全性，用以应对某些卑鄙的攻击类型（尽管目前很少被利用）。 如果打算编译内核/内核模块或使用 NVIDIA/ATI 私有驱动程序，那就最好禁用安全启动 (Secure Boot)。或者你可以启用安全启动 (Secure Boot)，然后阅读有关配置信任链和对内核/内核模块签名的说明。但是这一过程至少需要好几天。 不要在 MBR 格式的磁盘上进行原生 UEFI 安装，也不要在 GPT 格式的磁盘上进行 BIOS 兼容安装（如果没记错的话，除非你的磁盘大小大于 2.2TB，因为 MBR 格式无法识别那么大的磁盘。如果想在那么大的磁盘上进行 BIOS 兼容安装，那么你可能会卡在 BIOS+GPT 的组合上。虽然这种组合可以正常运行，但是有点不靠谱，而且会牵涉到臭名昭著的“BIOS Boot 分区”）。 相信 mjg59 及其他权威人士，包括我。 这一整节都是简化过的内容——当启动已安装的操作系统时，无论启动装载程序是否安装在“ESP”上，对固件都没有影响；固件只会读取启动管理器项，然后尝试访问特定分区并执行特定可执行文件，具体请参阅 pjones 的说明。但是一般会使用 ESP 来进行启动过程，因为 UEFI 规范中有相应规定，而且这个分区也很方便，固件可以读取其文件系统。理论上来说，在固件执行可移动介质/回退路径 (Fallback path) 启动时，ESP 将不起作用。 注意，这只是我的个人推断。在整个规范的制定过程中，我都没有参与，也没人告诉我这些内容。但是根据已知事实，明显可以得出这一推断。","raw":null,"content":null,"categories":[{"name":"Linux","slug":"Linux","permalink":"https://ygcaicn.github.io/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://ygcaicn.github.io/tags/Linux/"},{"name":"grub","slug":"grub","permalink":"https://ygcaicn.github.io/tags/grub/"}]},{"title":"收集整理各高校ACM OJ网站，欢迎补充修正","slug":"acmurl","date":"2016-10-24T12:28:32.000Z","updated":"2018-01-15T12:56:44.565Z","comments":true,"path":"杂项/acmurl.html","link":"","permalink":"https://ygcaicn.github.io/杂项/acmurl.html","excerpt":"搜集的各大高校的ACM网站…","text":"搜集的各大高校的ACM网站… 中国：(China)华东地区：浙江：杭州电子科技大学(HDU)：http://acm.hdu.edu.cn/ 浙江大学（ZJU）：http://acm.zju.edu.cn/ 浙江工业大学（ZJUT）：http://acm.zjut.edu.cn/ 浙江师范大学（ZJNU）：http://acm.zjnu.cn/ 浙江工商（ZJGSU）：http://acm.zjgsu.edu.cn/ 宁波理工（NIT）：http://acm.nit.net.cn/ 上海：华东师范大学（ECNU）：http://acm.cs.ecnu.edu.cn/ 华东理工大学（ECUST）：http://acm.ecust.edu.cn/ 同济大学（TJU）：http://acm.tongji.edu.cn/ 江苏：中国矿业大学（CUMT）： http://219.219.62.238 (我也不懂为啥连个域名都没有)南京航空航天大学： http://acm.nuaa.edu.cn/ 福建：福州大学（FZU）：http://acm.fzu.edu.cn/ 厦门大学（XMU）：http://acm.xmu.edu.cn/ 福建师范大学（FJNU）：http://acm.fjnu.edu.cn/ 安徽：中国科技大学（USTC）：http://acm.ustc.edu.cn/ 华北地区： 北京：北京交大（BJTU）：http://acm.bjtu.edu.cn/ 北京大学（PKU）：http://acm.pku.edu.cn/ 天津：南开大学（NAIKAI）：http://acm.nankai.edu.cn/ 天津大学（TJU）：http://acm.tju.edu.cn/toj/ 东北地区：黑龙江：哈尔滨工程大学（HRBEU）：http://acm.hrbeu.edu.cn/ 华南地区：广东：中山大学（ZSU）：http://acm.zsu.edu.cn/西南地区：四川：西南民大（SWUN）：http://acm.swun.edu.cn/ 华中地区：湖北：华中科技大学（HUST）：http://acm.hust.edu.cn/JudgeOnline/ 武汉大学（WHU）：http://acm.whu.edu.cn/ 港澳台地区：香港：香港大学(HKOI)：http://judge.hkoi.org/ 俄罗斯：(Russia) 乌拉尔大学（URAL）：http://acm.timus.ru/ 萨拉托夫大学（SGU）：http://acm.sgu.ru/ (vallod) ：http://acm.uva.es/ EL Judge(MIPT):：http://acm.mipt.ru/judge/problems.pl 西班牙：(Spanish) 瓦拉杜利德大学（UVA）：http://acm.uva.es/ 美国：(America)USACO: http://train.usaco.org/usacogate 波兰：(Poland) SPOJ：http://www.spoj.pl/ 吉尔吉斯斯坦:：(Kirgizstan) KRSU: http://www.olymp.krsu.edu.kg/GeneralProblemset.aspx 中国各大高校BBS:http://acm.hdu.edu.cn/forum/（杭电） http://www.hdubbs.com/（杭电） http://www.freecity.cn/（浙大） http://bbs.freecity.cn/(浙大) Others： Topcoder：http://www.topcoder.com/tc ACM-ICPC：http://icpc.baylor.edu/icpc/ 美国信息学奥林匹克竞赛官方网站：http://www.usaco.org/ 全美计算机奥林匹克竞赛：http://ace.delos.com/usacogate 信息学初学者之家：http://oibh.ioiforum.org/ 中国教育曙光网：http://www.chinaschool.org/aosai/ 福建信息学奥林匹克：http://www.cfcs.com.cn/fjas/index.htm IOI：http://olympiads.win.tue.nl/ioi/ 高效信息学在线判题系统（VIJOS）：http://www.vijos.cn/ ACM的例程和测试数据：http://www.karrels.org/Ed/ACM/ ACM社区：http://www.608088.com/","raw":null,"content":null,"categories":[{"name":"杂项","slug":"杂项","permalink":"https://ygcaicn.github.io/categories/杂项/"}],"tags":[{"name":"编程","slug":"编程","permalink":"https://ygcaicn.github.io/tags/编程/"}]},{"title":"C++练习笔记（持续更新）","slug":"cpplianxi","date":"2016-10-24T11:28:32.000Z","updated":"2018-01-15T10:02:21.759Z","comments":true,"path":"Cpp/cpplianxi.html","link":"","permalink":"https://ygcaicn.github.io/Cpp/cpplianxi.html","excerpt":"前言由于近一年来学习嵌入式大多接触的都是纯C语言，直到看到学校搞了一个程序设计大赛，才发现自己的C++的基础遗忘了好多。不过这也是正常的，毕竟三天不练手生，学习其他知识的同时不要忘记基础！！将练习记录写在博客中一来方便以后查阅，而来和大家一起学习！\n查了查以前囤下的C++API手册发现是C++98的，这有点让我不开心了，于是上网搜寻了一番，发现没有找到好的本地手册，oschina的手册做的不能再垃圾，连个search都没有。去一些cpp的权威网站当然是英文的，但是发现不怎么活跃。这怎么能满足我这种完美主义的程序爱好者呢。。。最后搜寻了一番终于找到了满意的手册，不过美中不足的是不能本地化。不过这也没什么这说明网站更新活跃嘛！下面附上链接，欢迎各位Ctrl+D:\nCpp编程手册\ncplusplus reference","text":"前言由于近一年来学习嵌入式大多接触的都是纯C语言，直到看到学校搞了一个程序设计大赛，才发现自己的C++的基础遗忘了好多。不过这也是正常的，毕竟三天不练手生，学习其他知识的同时不要忘记基础！！将练习记录写在博客中一来方便以后查阅，而来和大家一起学习！ 查了查以前囤下的C++API手册发现是C++98的，这有点让我不开心了，于是上网搜寻了一番，发现没有找到好的本地手册，oschina的手册做的不能再垃圾，连个search都没有。去一些cpp的权威网站当然是英文的，但是发现不怎么活跃。这怎么能满足我这种完美主义的程序爱好者呢。。。最后搜寻了一番终于找到了满意的手册，不过美中不足的是不能本地化。不过这也没什么这说明网站更新活跃嘛！下面附上链接，欢迎各位Ctrl+D: Cpp编程手册 cplusplus reference 本文程序大多基于C++11特性，除非特别声明！！ 输入不定量数据，求和12345678910int main()&#123;int sum = 0, val = 0;cout &lt;&lt; \"输入一组数据，以Ctrl+Z结束,Enter 计算\" &lt;&lt; endl;while (cin &gt;&gt; val)sum += val;cout &lt;&lt; \"sum=\" &lt;&lt;sum&lt;&lt; endl;system(\"pause\"); return 0;&#125; 将字符串的小写转换为大写，统计字符串等string 引用 12345678910111213141516171819#include \"stdafx.h\"#include \"cctype\"using namespace std;int main()&#123;string str;getline(cin, str);for (auto &amp;c : str)&#123;//if(c&gt;='a'&amp;&amp;c&lt;='z')if(islower(c))&#123;c = c - 'a' + 'A';&#125;&#125;cout &lt;&lt; str&lt;&lt;endl;system(\"pause\"); return 0;&#125; A+B probles的一道Acm题Description Calculate a + b Input The input will consist of a series of pairs of integers a and b,separated by a space, one pair of integers per line. Output For each pair of input integers a and b you should output the sum of a and b in one line,and with one line of output for each line in input. Sample Input 1 2 3 4 Sample Output 3 7 12345678910111213141516171819#include \"stdafx.h\"#include &lt;vector&gt;using namespace std;int main()&#123;int a, b;vector&lt;int&gt; slove;int tmp;while (cin &gt;&gt; a&amp;&amp;cin &gt;&gt; b)&#123;tmp= (a + b);slove.push_back(tmp);&#125;for(auto i:slove)cout &lt;&lt; (int)i &lt;&lt; endl;system(\"pause\"); return 0;&#125; 无奈这么写上传之后直接编译不通过。。。看来acm的系统是不支持C++11特性的。。明天再写C++98的吧。。 看来是我太不了解OJ了，回头好好学习一下OJ的基本输入和输出。下面附上正确的程序： 1234567891011#include&lt;iostream&gt;using namespace std;int main()&#123; int a, b; while (cin &gt;&gt; a &gt;&gt; b) &#123; cout &lt;&lt; a + b &lt;&lt; endl; &#125; return 0;&#125; char * 数组的遍历操作 输入字符串若满足：首字母大写，后面全为小写返回1，否则返回0。如Hello满足条件 123456789101112131415int fun(char *str)&#123; if ((*str)&gt;'A' &amp;&amp; (*str)&lt;'Z') &#123; while (*(++str)) &#123; if ((*str)&lt;'a' || (*str)&gt;'z') &#123; return 0; &#125; &#125; return 1; &#125; return 0;&#125; 将输入的字符串中的字符全部变为ASCII码表中的下一个字符. 123456789void fun(char *str)&#123; int i = 0; while (*(str+i)) &#123; (*(str + i))++; i++; &#125;&#125; 寻找两个字符串第一个不同的位置,下标从0开始，如果全部相同返回-1 123456789101112131415161718192021int fun(char *str1, char *str2)&#123; size_t length = strlen(str1); size_t length2 = strlen(str2); length = length &lt; length2 ? length:length2; int i; for (i = 0; i &lt; length; i++) &#123; char c1 = str1[i], c2 = str2[i]; if (c1 &gt; 'a'&amp;&amp;c1 &lt; 'z') c1 = c1 - ('a' - 'A'); if (c2 &gt;= 'a'&amp;&amp;c2 &lt;= 'z') c2 = c2 - ('a' - 'A'); if (c1!=c2) break; &#125; if (i == length) return -1; return i;&#125; 检索出字符串中出现最多的字符，并返回该字符 ASCII共定义了256个代码(从0-255)，从0-32位为控制字符(33个)(ASCII control characters)，从33-127位为可打印字符(95个)(ASCII printable characters)。从0-127是标准的ASCII编码，从128-255是扩展的ASCII编码。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include \"stdafx.h\"#include&lt;iostream&gt;#include &lt;string&gt;using namespace std;//检索出字符串中出现最多的字符，并返回该字符char fun(char *str)&#123; char *tstr = str; int tmp[100] = &#123;0&#125;; while (*tstr) &#123; //相对首个可打印字符位置 tmp[int(*tstr)-32]++; tstr++; &#125; //去除大小写差异 for (int i = 'A'-32;i&lt;='Z'-32; i++) &#123; tmp[i] += tmp[i + 'a' - 'A']; // tmp[i + 'a' - 'A']=tmp[i]; &#125; //找到最大的 char maxstr = 0; int maxnum = 0; for (int i = 0; i &lt; 100; i++) &#123; if (tmp[i] &gt; maxnum) &#123; maxnum = tmp[i]; maxstr = i; &#125; &#125; //判断是否只出现大写或只出现小写 //大小写同时出现返回大写 if (tmp[maxstr] &gt; tmp[maxstr + 'a' - 'A']) maxstr += 32; else maxstr += 32+'a' - 'A'; return maxstr;&#125;int main()&#123; char str[100]; cin &gt;&gt; str; cout &lt;&lt; \"次数最多的是：\" &lt;&lt; fun(str) &lt;&lt; endl; system(\"pause\"); return 0;&#125; 同样的要求，一位大神给出的程序，让我看到了差距： 12345678910111213141516171819202122232425262728293031323334353637char fun(char *str)&#123; char o = 'a' - 'A'; char c = '\\0'; //存储ASCII256个字符的的出现次数 int data[256]; memset(data, 0, 256 * sizeof(int)); size_t length = strlen(str); //遍历字符串 for (int i = 0; i&lt;length; i++) &#123; c = str[i]; data[c]++; if (c &gt;= 'A' &amp;&amp; c &lt;= 'Z' &amp;&amp; data[c + o] &gt; 0) &#123; data[c + o]++; &#125; if (c &gt;= 'a' &amp;&amp; c &lt;= 'z' &amp;&amp; data[c - o] &gt; 0) &#123; data[c - o]++; &#125; &#125; //找出最大的 char result = '\\0'; int maxNumber = 0; for (int i = 0; i&lt;256; i++) &#123; int number = data[i]; if (number &gt; maxNumber) &#123; result = i; maxNumber = number; &#125; &#125; return result;&#125; getline获取一行输入，以回车符触发getline结束，且不保存最后的回车符空行结束输入，（注意与文件尾EOF结束的区别） 12345678910111213141516171819#include \"stdafx.h\"#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;int main()&#123; string str; vector &lt;string&gt; vec;while (getline(cin,str)&amp;&amp;!str.empty())&#123; vec.push_back(str);&#125;for (auto i : vec)&#123; cout &lt;&lt; i&lt;&lt; endl;&#125;system(\"pause\");return 0;&#125; vector列表初始化，元素引用12345678910111213141516171819#include \"stdafx.h\"#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;int main()&#123; //构造函数初始化 //vector &lt;int&gt; vec(10,1); //列表初始化 vector &lt;int&gt; vec = &#123;1,2,3,4,5,6,7,8,9&#125;; for (auto &amp;i : vec) &#123; i = i*i; cout &lt;&lt; i&lt;&lt; '\\t'; &#125; system(\"pause\"); return 0;&#125; vector常用操作12345vec.empty() //如果vec不含有任何元素返回真，否则返回假vec.size() //返回元素的个数vec.push_back() //添加元素vex.pop_back() //删除元素//……更多参见[cppreference](http://zh.cppreference.com/w/cpp/container/vector) 迭代器迭代器类似于指针类型，提供了我们间接访问对象的方法。我们利用指针可以访问各种数据类型的内容，采用的是 * 符进行 每天进步一点点!!!impossible is I’m possible!!!","raw":null,"content":null,"categories":[{"name":"Cpp","slug":"Cpp","permalink":"https://ygcaicn.github.io/categories/Cpp/"}],"tags":[{"name":"Cpp","slug":"Cpp","permalink":"https://ygcaicn.github.io/tags/Cpp/"}]},{"title":"lamp服务器搭建-centos7+Apache2.4+MariaDB+php5.6+phpmyadmin","slug":"lamp-centos7","date":"2016-10-22T15:43:54.000Z","updated":"2018-01-15T10:21:55.789Z","comments":true,"path":"Linux/lamp-centos7.html","link":"","permalink":"https://ygcaicn.github.io/Linux/lamp-centos7.html","excerpt":"centos7 下yum搭建服务器以及数据库的流程。","text":"centos7 下yum搭建服务器以及数据库的流程。 安装httpd直接yum源安装就可以，centos7的yum源是Apache2.4 yum install httpd apache常用指令1234systemctl start httpd #启动apachesystemctl stop httpd #停止apachesystemctl restart httpd #重启apachesystemctl enable httpd #设置apache开机启动 配置两个扩展yum源yum install epel-release rpm -Uvh http://rpms.famillecollet.com/enterprise/remi-release-7.rpm 因为centos7默认的yum源php是5.4的，有点跟不上时代的脚步啊。。。所以使用扩展yum源进行安装。 php相关模块yum --enablerepo=remi-php56 install php php-cli php-pear php-pdo php-mysqlnd php-gd php-mbstring php-mcrypt php-xml phpmyadminyum --enablerepo=remi-php56 install phpmyadmin 这里指定php的版本是必须的，有很多教程就是这里出了问题。。。 phpmyadmin配置：1234567#打开phpmyadmin的配置文件vim /etc/httpd/conf.d/phpMyAdmin.conf将Allow from 127.0.0.1Allow from ::1改为： Require all grantedsystemctl restart httpd #重启apache 安装MariaDBCentOS 7.0中，已经使用MariaDB替代了MySQL数据库 安装MariaDByum install mariadb mariadb-server #询问是否要安装，输入Y即可自动安装,直到安装完成 常用MariaDB指令12345systemctl start mariadb.service #启动MariaDBsystemctl stop mariadb.service #停止MariaDBsystemctl restart mariadb.service #重启MariaDBsystemctl enable mariadb.service #设置开机启动cp /usr/share/mysql/my-huge.cnf /etc/my.cnf #拷贝配置文件（注意：如果/etc目录下面默认有一个my.cnf，直接覆盖即可） 为root账户设置密码1234567mysql_secure_installation#回车，根据提示输入Y#输入2次密码，回车#根据提示一路输入Y#最后出现：Thanks for using MySQL!#MySql密码设置完成，重新启动 MySQL：systemctl restart mariadb.service #重启MariaDB 新建数据库账户进入数据库mysql -u root -p show databases 最后开启相应的端口就可以外网访问了，关于firewalld的相关操作请参考CentOS7使用firewalld管理防火墙与端口 每天进步一点点!!!impossible is I’m possible!!!","raw":null,"content":null,"categories":[{"name":"Linux","slug":"Linux","permalink":"https://ygcaicn.github.io/categories/Linux/"}],"tags":[{"name":"LAMP","slug":"LAMP","permalink":"https://ygcaicn.github.io/tags/LAMP/"}]},{"title":"CentOS7使用firewalld管理防火墙与端口","slug":"firewalld-centos7","date":"2016-10-22T13:24:46.000Z","updated":"2018-01-15T10:14:56.725Z","comments":true,"path":"Linux/firewalld-centos7.html","link":"","permalink":"https://ygcaicn.github.io/Linux/firewalld-centos7.html","excerpt":"CentOS7使用firewalld打开关闭防火墙与端口\n1、firewalld的基本使用12345启动： systemctl start firewalld查看状态： systemctl status firewalld停止： systemctl disable firewalld禁用： systemctl stop firewalldsystemctl list-unit-files | grep firewalld #查看是否加入开机启","text":"CentOS7使用firewalld打开关闭防火墙与端口 1、firewalld的基本使用12345启动： systemctl start firewalld查看状态： systemctl status firewalld停止： systemctl disable firewalld禁用： systemctl stop firewalldsystemctl list-unit-files | grep firewalld #查看是否加入开机启 2.systemctl是CentOS7的服务管理工具中主要的工具，它融合之前service和chkconfig的功能于一体。123456789启动一个服务：systemctl start firewalld.service关闭一个服务：systemctl stop firewalld.service重启一个服务：systemctl restart firewalld.service显示一个服务的状态：systemctl status firewalld.service在开机时启用一个服务：systemctl enable firewalld.service在开机时禁用一个服务：systemctl disable firewalld.service查看服务是否开机启动：systemctl is-enabled firewalld.service查看已启动的服务列表：systemctl list-unit-files|grep enabled查看启动失败的服务列表：systemctl --failed 3.配置firewalld-cmd12345678910查看版本： firewall-cmd --version查看帮助： firewall-cmd --help显示状态： firewall-cmd --state查看所有打开的端口： firewall-cmd --zone=public --list-ports更新防火墙规则： firewall-cmd --reload查看区域信息: firewall-cmd --get-active-zones查看指定接口所属区域： firewall-cmd --get-zone-of-interface=eth0拒绝所有包：firewall-cmd --panic-on取消拒绝状态： firewall-cmd --panic-off查看是否拒绝： firewall-cmd --query-panic 开启一个端口12345678910111213141516171819202122232425在vim /etc/firewalld/zones/public.xml 加入端口或者服务 &lt;service name=&quot;http&quot;/&gt; &lt;service name=&quot;https&quot;/&gt; &lt;port protocol=&quot;tcp&quot; port=&quot;8080&quot;/&gt; 或者 firewall-cmd --zone=public --add-port=8080/tcp --permanent firewall-cmd --zone=public --add-service=http --permanent firewall-cmd --zone=public --add-service=https --permanent 命令含义： --zone #作用域 --add-port=80/tcp #添加端口，格式为：端口/通讯协议 firewall-cmd --zone=public --add-port=8001/tcp --permanent #永久生效，没有此参数重启后失效 查看是否启用： firewall-cmd --permanent --zone=public --query-port=8080/tcp firewall-cmd --permanent --zone=public --query-service=http 删除端口或者服务： firewall-cmd --zone=public --remove-service=http --permanent firewall-cmd --zone=public --remove-port=8080/tcp --permanent开启连续多个端口：firewall-cmd --zone=public --add-port=1000-1500/tcp --permanent 每天进步一点点!!!impossible is I’m possible!!!","raw":null,"content":null,"categories":[{"name":"Linux","slug":"Linux","permalink":"https://ygcaicn.github.io/categories/Linux/"}],"tags":[{"name":"CentOS7","slug":"CentOS7","permalink":"https://ygcaicn.github.io/tags/CentOS7/"}]},{"title":"科学上网","slug":"科学上网","date":"2016-10-16T13:03:10.000Z","updated":"2018-01-15T10:39:16.116Z","comments":true,"path":"Network/科学上网.html","link":"","permalink":"https://ygcaicn.github.io/Network/科学上网.html","excerpt":"持续更新，Shadowsocks下载 2016最新版（影梭，小飞机客户端）Shadowsocks（中文名称：影梭）是一个安全的socks5代理，用于保护网络流量，是一个开源项目。\n特性快速（异步I/O和事件驱动程序）安全（所有的流量都经过加密算法加密，支持自定义算法）支持移动客户端（专为移动设备和无线网络优化）跨平台（可运行于包括PC，Mac，手机（Android和iOS）和路由器（OpenWrt）在内的多种平台上）\n开源易于维护按下Ctrl点击-&gt;github地址","text":"持续更新，Shadowsocks下载 2016最新版（影梭，小飞机客户端）Shadowsocks（中文名称：影梭）是一个安全的socks5代理，用于保护网络流量，是一个开源项目。 特性快速（异步I/O和事件驱动程序）安全（所有的流量都经过加密算法加密，支持自定义算法）支持移动客户端（专为移动设备和无线网络优化）跨平台（可运行于包括PC，Mac，手机（Android和iOS）和路由器（OpenWrt）在内的多种平台上） 开源易于维护按下Ctrl点击-&gt;github地址 下载地址：按下Ctrl点击-&gt;shadowsocks官网本站下载：按下Ctrl点击-&gt;官方下载地址 按下Ctrl点击-&gt;windows百度网盘下载 密码: 7w8y|本地下载 按下Ctrl点击-&gt;Android客户端：Google Play |百度网盘 密码: | Ggithub 按下Ctrl点击-&gt; Linux 客户端:shadowsocks-gui [按下Ctrl点击-&gt;] iOS 客户端:shadowsocks-iOS | MobileShadowSocks 本页持续更","raw":null,"content":null,"categories":[{"name":"Network","slug":"Network","permalink":"https://ygcaicn.github.io/categories/Network/"}],"tags":[{"name":"shadowsocks","slug":"shadowsocks","permalink":"https://ygcaicn.github.io/tags/shadowsocks/"}]},{"title":"免费设置QQ空间音乐记 qzone music","slug":"qzonemusic","date":"2016-10-16T11:32:07.000Z","updated":"2018-01-15T10:24:20.984Z","comments":true,"path":"杂项/qzonemusic.html","link":"","permalink":"https://ygcaicn.github.io/杂项/qzonemusic.html","excerpt":"如今有了智能终端，Web QQ空间好像越来越冷落。可是QQ空间的背景音乐仍然是要收费的，奈我何，发现了腾讯还是给屌丝们留了一条活路！！！\n按照以下步骤免费获得QQ空间背景音乐。\na.进入QQ空间","text":"如今有了智能终端，Web QQ空间好像越来越冷落。可是QQ空间的背景音乐仍然是要收费的，奈我何，发现了腾讯还是给屌丝们留了一条活路！！！ 按照以下步骤免费获得QQ空间背景音乐。 a.进入QQ空间 b.点击背景音乐，进入背景音乐设置的页面 c.然后点击-添加网络音乐 有三个选项要填： 歌曲链接 最重要的就是这个，这里需要一个MP3外链 http://pubcdn.cumtpn.com/G.E.M.%20%E9%82%93%E7%B4%AB%E6%A3%8B%20-%20%E7%94%BB%20%28Live%20Piano%20Session%20II%29.mp3 这是邓紫棋-画的外链 歌曲名 随便填就是啦 歌手名 随便填就是啦 填完点击添加就是了。就是这么简单你会发现你已经添加上啦！ 添加成功添加成功刷新QQ空间就能直接播放额。这是添加成功的图： 不过不幸的是网络上的mp3外链不好找，像什么 百度音乐、QQ音乐、天天动听之类的是不会轻易放出外链的。 下面是我在我的七牛CDN公开的外链： 孙露-怎样遇见你： http://pubcdn.cumtpn.com/%E5%AD%99%E9%9C%B2%20-%20%E6%80%8E%E6%A0%B7%E9%81%87%E8%A7%81%E4%BD%A0.mp3 邓紫棋-画： http://pubcdn.cumtpn.com/G.E.M.%20%E9%82%93%E7%B4%AB%E6%A3%8B%20-%20%E7%94%BB%20%28Live%20Piano%20Session%20II%29.mp3 有需要的欢迎留言歌曲名+歌手，我免费为大家添加外链！！！","raw":null,"content":null,"categories":[{"name":"杂项","slug":"杂项","permalink":"https://ygcaicn.github.io/categories/杂项/"}],"tags":[]},{"title":"Markdown Syntax Tutorial","slug":"Syntax","date":"2016-10-15T14:22:01.000Z","updated":"2018-01-15T10:25:16.976Z","comments":true,"path":"杂项/Syntax.html","link":"","permalink":"https://ygcaicn.github.io/杂项/Syntax.html","excerpt":"MarkDown语法简明TitleThis is first paragraph!\nThis is second paragraph!\n1.段落的前后必须有一个空行，否则换行符会被替换为空格2.行内要换行的话，必须在上一行的最后空上至少两个空格或者加入&lt;br/&gt;实现换行.\n3. Markdown 中的多数区块都需要在两个空行之间。","text":"MarkDown语法简明TitleThis is first paragraph! This is second paragraph! 1.段落的前后必须有一个空行，否则换行符会被替换为空格2.行内要换行的话，必须在上一行的最后空上至少两个空格或者加入&lt;br/&gt;实现换行. 3. Markdown 中的多数区块都需要在两个空行之间。 一级标题二级标题三级标题四级标题五级标题六级标题我在左侧加了空格一级标题的另一种写法H1二级标题H2 引用的内容（blockquote）引用内容引用的嵌套 内部的quote内部的引用 有序列表1.第一条2.第二条4.第三条 无序列表 第一条 第二条 第三条 嵌套的列表 第一条 第一例 第二例 第二条 第二例 第二例 第三例 第三条 代码#include&lt;iostream&gt; #using namespce std; int main() { cout&lt;&lt;&quot;Hello world&quot;&lt;&lt;end; return 0; } 通过前面的Table来写代码块 #include&lt;iostream&gt;#using namespce std;int main(){cout&lt;&lt;&quot;Hello world&quot;&lt;&lt;end;return 0;} 另一种形式 ##分割线 两种形式 都必须单独占一个段落，每个分割符为一个区块，前后必须空行，中间无所谓 超链接text 行内式 网页链接： I like Google This is my homepage 文件连接： icon 包含Title的连接 google 参考式 Google Baidu GitHub 自动链接 www.google.com http://www.google.com http://www.google.com name@gmail.com &#110;&#x61;&#109;&#x65;&#64;&#103;&#x6d;&#x61;&#105;&#108;&#x2e;&#x63;&#111;&#x6d; 图片 嵌入Html 强调斜体强调 粗体强调 *粗体强调* 字符转义例如 #标题 *粗体强调* ##删除线 ~删除线删除这些文字~ ##多行代码 1234567#include&lt;iostream&gt;using namespace std;int main() &#123; cout&lt;&lt;\"Hello world!\"&lt;&lt;endl; return 0; &#125; TaskList [ ] Eat [x] Code [x] HTML [x] CSS [x] JavaScript [ ] Sleep Graphy name age LearnShare 12 Mike 32","raw":null,"content":null,"categories":[{"name":"杂项","slug":"杂项","permalink":"https://ygcaicn.github.io/categories/杂项/"}],"tags":[{"name":"MarkDown","slug":"MarkDown","permalink":"https://ygcaicn.github.io/tags/MarkDown/"},{"name":"github","slug":"github","permalink":"https://ygcaicn.github.io/tags/github/"}]},{"title":"socks5,socks4,http,vpn 代理是怎么回事","slug":"proxy","date":"2016-10-15T10:28:55.000Z","updated":"2018-01-15T10:23:37.335Z","comments":true,"path":"Network/proxy.html","link":"","permalink":"https://ygcaicn.github.io/Network/proxy.html","excerpt":"一、什么是代理服务器？ 代理服务器英文全称是Proxy Server，其功能就是代理网络用户去取得网络信息。形象的说：它是网络信息的中转站。 在一般情况下，我们使用网络浏览器直接去连接其他Internet站点取得网络信息时，需送出Request信号来得到回答，然后对方再把信息以bit方式传送回来。代理服务器是介于浏览器和Web服务器之间的一台服务器，有了它之后，浏览器不是直接到Web服务器去取回网页而是向代理服务器发出请求， Request信号会先送到代理服务器，由代理服务器来取回浏览器所需要的信息并传送给你的浏览器。而且，大部分代理服务器都具有缓冲的功能，就好象一个大的Cache，它有很大的存储空间，它不断将新取得数据储存到它本机的存储器上，如果浏览器所请求的数据在它本机的存储器上已经存在而且是最新的，那么它就不重新从Web服务器取数据，而直接将存储器上的数据传送给用户的浏览器，这样就能显著提高浏览速度和效率。 更重要的是：Proxy Server (代理服务器)是 Internet链路级网关所提供的一种重要的安全功能，它的工作主要在开放系统互联 (OSI) 模型的对话层。","text":"一、什么是代理服务器？ 代理服务器英文全称是Proxy Server，其功能就是代理网络用户去取得网络信息。形象的说：它是网络信息的中转站。 在一般情况下，我们使用网络浏览器直接去连接其他Internet站点取得网络信息时，需送出Request信号来得到回答，然后对方再把信息以bit方式传送回来。代理服务器是介于浏览器和Web服务器之间的一台服务器，有了它之后，浏览器不是直接到Web服务器去取回网页而是向代理服务器发出请求， Request信号会先送到代理服务器，由代理服务器来取回浏览器所需要的信息并传送给你的浏览器。而且，大部分代理服务器都具有缓冲的功能，就好象一个大的Cache，它有很大的存储空间，它不断将新取得数据储存到它本机的存储器上，如果浏览器所请求的数据在它本机的存储器上已经存在而且是最新的，那么它就不重新从Web服务器取数据，而直接将存储器上的数据传送给用户的浏览器，这样就能显著提高浏览速度和效率。 更重要的是：Proxy Server (代理服务器)是 Internet链路级网关所提供的一种重要的安全功能，它的工作主要在开放系统互联 (OSI) 模型的对话层。 二、代理服务器的分类1. HTTP代理按匿名功能分类。 是否具有隐藏IP的功能。 非匿名代理：不具有匿名功能。 匿名代理。使用此种代理时，虽然被访问的网站不能知道你的IP地址，但仍然可以知道你在使用代理，有些侦测IP的网页也仍然可以查到你的IP。 高度匿名代理：使用此种代理时，被访问的网站不知道你的IP地址，也不知道你在使用代理进行访问。此种代理的隐藏IP地址的功能最强。 2. 按请求信息的安全性分类 全匿名代理：不改变你的request fields（报文），使服务器端看来就像有个真正的客户浏览器在访问它。当然，你的真实IP是隐藏起来的。服务器的网管不会认为你使用了代理。 普通匿名代理：能隐藏你的真实IP，但会更改你的request fields，有可能会被认为使用了代理，但仅仅是可能，一般说来是没问题的。不过不要受它的名字的误导，其安全性可能比全匿名代理更高，有的代理会剥离你的部分信息（就好比防火墙的stealth mode），使服务器端探测不到你的操作系统版本和浏览器版本。 elite代理：匿名隐藏性更高，可隐藏系统及浏览器资料信息等。此种代理安全性特强。 透明代理（简单代理）：透明代理的意思是客户端根本不需要知道有代理服务器的存在，它改编你的request fields（报文），并会传送真实IP。 注意，加密的透明代理则是属于匿名代理，意思是不用设置使用代理了，例如Garden 2程序。 3. 按代理服务器的用途分类1. Http代理：代理客户机的http访问，主要代理浏览器访问网页，它的端口一般为80、8080、3128等。 2. SSL代理:支持最高128位加密强度的http代理，可以作为访问加密网站的代理。加密网站是指以https://开始的网站。ssl的标 准端口为443。 3. HTTP CONNECT代理：允许用户建立TCP连接到任何端口的代理服务器，这种代理不仅可用于HTTP，还包括FTP、IRC、 RM流服务等。 4. FTP代理：代理客户机上的ftp软件访问ftp服务器，其端口一般为21、2121。 5. POP3代理：代理客户机上的邮件软件用pop3方式收邮件，其端口一般为110。 6. Telnet代理：能够代理通信机的telnet，用于远程控制，入侵时经常使用。其端口一般为23。 7. Socks代理：是全能代理，就像有很多跳线的转接板，它只是简单地将一端的系统连接到另外一端。支持多种协议，包括http、ftp请求及其它类型的请求。它分socks 4 和socks 5两种类型，socks 4只支持TCP协议而socks 5支持TCP/UDP协议，还支持各种身份验证机制等协议。其标准端口为1080。 socks代理相应的采用socks协议的代理服务器就是SOCKS服务器，是一种通用的代理服务器。Socks是个电路级的底层网关，是 DavidKoblas在1990年开发的，此后就一直作为Internet RFC标准的开放标准。Socks不要求应用程序遵循特定的操作系统平台，Socks 代理与应用层代理、 HTTP 层代理不同，Socks代理只是简单地传递数据包，而不必关心是何种应用协议（比如FTP、HTTP和NNTP请求）。所以，Socks代理比其他应用层代理要快得多。它通常绑定在代理服务器的1080端口上。如果您在企业网或校园网上，需要透过防火墙或通过代理服务器访问Internet就可能需要使用 SOCKS。一般情况下，对于拨号上网用户都不需要使用它。注意，浏览网页时常用的代理服务器通常是专门的http代理，它和SOCKS是不同的。因此，您能浏览网页不等于您一定可以通过SOCKS访问Internet。常用的防火墙，或代理软件都支持SOCKS，但需要其管理员打开这一功能。如果您不确信您是否需要SOCKS或是否有SOCKS可用，请与您的网络管理员联系。 为了使用socks，您需要了解一下内容: SOCKS服务器的IP地址 SOCKS服务所在的端口 这个SOCKS服务是否需要用户认证？如果需要，您要向您的网络管理员申请一个用户和口令 知道了上述信息，您就可以把这些信息填入“网络配置”中，或者在第一次登记时填入，您就可以使用socks代理了。 在实际应用中SOCKS代理可以用作为：电子邮件、新闻组软件、网络传呼ICQ、网络聊天MIRC和使用代理服务器上联众打游戏等等各种游戏应用软件当中。 8. TUNNEL代理：经HTTPTunnet程序转换的数据包封装成http请求（Request）来穿透防火墙，允许利用HTTP服务器做任何TCP可以做的事情，功能相当于Socks5。 9. 文献代理：可以用来查询数据库的代理，通过这些代理，可以获得互联网的相关科研学术的数据库资源，例如查询Sciencedirect网站（简称SD）、Academic Press、IEEE，SPRINGER等数据库。 10. 教育网代理：指学术教育机构局域网通过特定的代理服务器可使无出国权限或无访问某IP段权限的计算机访问相关资源。 11. 跳板代理：应用于跳板程序，可以看作一种具有动态加密的特殊socks5代理，，也可直接用于PSD软件。其端口一般为1813。 12. Ssso代理：代理客户机上的ssso程序访问远程网站，具有SSL加密强度的超级代理，支持socks。 13. Flat代理：代理客户机上的flatsurfer程序访问远程网站，具有高强度加密数据流的特殊代理，支持socks，最大可设置三次级联，可以设置穿越代理。其端口一般为6700。 14. SoftE代理：代理客户机上的SoftEther程序访问远程网站，应用虚拟集线器HUB和虚拟网卡技术，具备VPN功能及多种认证方式的代理，符合https协议。 三、代理服务器的主要功能 代理服务器一般来讲，对于普通的网民的作用有以下几个（撇开一些高深的用处不谈，因为未必会用到）： 连接Internet与Intranet 充当firewall（防火墙）：因为所有内部网的用户通过代理服务器访问外界时，只映射为一个IP地址，所以外界不能直接访问到内部网；同时可以设置 IP地址过滤，限制内部网对外部的访问权限；另外，两个没有互联的内部网，也可以通过第三方的代理服务器进行互联来交换信息。 节省IP开销：如前面所讲，所有用户对外只占用一个IP，所以不必租用过多的IP地址，降低网络的维护成本。这样，局域局内没有与外网相连的众多机器就可以通过内网的一台代理服务器连接到外网，大大减少费用。当然也有它不利的一面，如许多网络黑客通过这种方法隐藏自己的真实IP地址，而逃过监视。 通过它来加快我们浏览某些网站的速度：有时候我们访问一些国外或者港台网站，速度慢得像蜗牛一样，但只要你正确的选用代理服务器，速度就可以得到提升，有时候这些速度的提升可是很明显的哦！本身带宽较小，通过带宽较大的proxy与目标主机连接。而且通常代理服务器都设置一个较大的硬盘缓冲区（可能高达几个GB或更大），当有外界的信息通过时，同时也将其保存到缓冲区中，当其他用户再访问相同的信息时，则直接由缓冲区中取出信息，传给用户，从而达到提高访问速度的目的。","raw":null,"content":null,"categories":[{"name":"Network","slug":"Network","permalink":"https://ygcaicn.github.io/categories/Network/"}],"tags":[{"name":"代理","slug":"代理","permalink":"https://ygcaicn.github.io/tags/代理/"}]},{"title":"Hexo搭建个人博客及NexT主题配置与优化","slug":"hexo-blog","date":"2016-10-14T15:04:19.000Z","updated":"2017-05-04T05:05:49.423Z","comments":true,"path":"杂项/hexo-blog.html","link":"","permalink":"https://ygcaicn.github.io/杂项/hexo-blog.html","excerpt":"","text":"命令行帮助12345678910111213141516171819202122232425262728D:\\Github\\blog-hexo&gt;hexo -helpUsage: hexo &lt;command&gt;Commands: clean Removed generated files and cache. config Get or set configurations. deploy Deploy your website. generate Generate static files. help Get help on a command. init Create a new Hexo folder. list List the information of the site migrate Migrate your site from other system to Hexo. new Create a new post. publish Moves a draft post from _drafts to _posts folder. render Render files with renderer plugins. server Start the server. version Display version information.Global Options: --config Specify config file instead of using _config.yml --cwd Specify the CWD --debug Display all verbose messages in the terminal --draft Display draft posts --safe Disable all plugins and scripts --silent Hide output on consoleFor more help, you can use &apos;hexo help [command]&apos; for the detailed informationor you can check the docs: http://hexo.io/docs/ 常用命令：hexo help #查看帮助 hexo init #初始化一个目录 hexo new &quot;postName&quot; #新建文章 hexo new page &quot;pageName&quot; #新建页面 hexo generate #生成网页，可以在 public 目录查看整个网站的文件 hexo server #本地预览，&apos;Ctrl+C&apos;关闭 hexo deploy #部署.deploy目录 hexo clean #清除缓存，强烈建议每次执行命令前先清理缓存，每次部署前先删除 .deploy 文件夹 简写： hexo n == hexo new hexo g == hexo generate hexo s == hexo server hexo d == hexo deploy 直接在命令行中操作出现一下错误：123456789101112131415161718D:\\Github\\blog-hexo&gt;hexo dINFO Deploying: gitINFO Clearing .deploy_git folder...INFO Copying files from public folder...&apos;git&apos; �����ڲ����ⲿ���Ҳ���ǿ����еĳ����������ļ�FATAL Something&apos;s wrong. Maybe you can find the solution here: http://hexo.io/docs/troubleshooting.htmlError: spawn git ENOENT at notFoundError (D:\\Github\\blog-hexo\\node_modules\\hexo-deployer-git\\node_modules\\hexo-util\\node_modules\\cross-spawn\\lib\\enoent.js:11:11) at verifyENOENT (D:\\Github\\blog-hexo\\node_modules\\hexo-deployer-git\\node_modules\\hexo-util\\node_modules\\cross-spawn\\lib\\enoent.js:46:16) at ChildProcess.cp.emit (D:\\Github\\blog-hexo\\node_modules\\hexo-deployer-git\\node_modules\\hexo-util\\node_modules\\cross-spawn\\lib\\enoent.js:33:19) at Process.ChildProcess._handle.onexit (internal/child_process.js:200:12)FATAL spawn git ENOENTError: spawn git ENOENT at notFoundError (D:\\Github\\blog-hexo\\node_modules\\hexo-deployer-git\\node_modules\\hexo-util\\node_modules\\cross-spawn\\lib\\enoent.js:11:11) at verifyENOENT (D:\\Github\\blog-hexo\\node_modules\\hexo-deployer-git\\node_modules\\hexo-util\\node_modules\\cross-spawn\\lib\\enoent.js:46:16) at ChildProcess.cp.emit (D:\\Github\\blog-hexo\\node_modules\\hexo-deployer-git\\node_modules\\hexo-util\\node_modules\\cross-spawn\\lib\\enoent.js:33:19) at Process.ChildProcess._handle.onexit (internal/child_process.js:200:12) 原因是：git的执行目录没有加入系统环境变量。解决方案：1.将git加入环境变量Path中。2.直接在git shell中进行操作。我更习惯于方式2。 环境搭建好以后，常用到的就是增加新的博客然后提交git。以下操作均在git shell中操作 操作目录： 1234567891011YGC@YGC /d/Github$ cd blog-hexo/YGC@YGC /d/Github/blog-hexo$ pwd/d/Github/blog-hexoYGC@YGC /d/Github/blog-hexo$ ls_config.yml node_modules/ public/ scaffolds/ themes/db.json package.json readme.md source/ upload.bat 1234hexo n &quot;Linux基础&quot;hexo cleanhexo s -p 5500hexo d -g Error message “Filename too long”git config --system core.longpaths true","raw":null,"content":null,"categories":[{"name":"杂项","slug":"杂项","permalink":"https://ygcaicn.github.io/categories/杂项/"}],"tags":[{"name":"github","slug":"github","permalink":"https://ygcaicn.github.io/tags/github/"},{"name":"hexo","slug":"hexo","permalink":"https://ygcaicn.github.io/tags/hexo/"},{"name":"博客","slug":"博客","permalink":"https://ygcaicn.github.io/tags/博客/"}]},{"title":"GitHub入门记 Go Git!!!","slug":"git","date":"2016-10-14T13:14:28.000Z","updated":"2018-01-15T10:17:00.001Z","comments":true,"path":"建站/git.html","link":"","permalink":"https://ygcaicn.github.io/建站/git.html","excerpt":"git install and config\ninstall Linux:\n1shell 界面输入 ``sudo  apt-get install git-core`` 回车输入密码\n\nWindows：下载\n12345[git-for-windows](https://github.com/git-for-windows/git/releases/tag/v2.6.3.windows.1)[github-windows](https://github-windows.s3.amazonaws.com/GitHubSetup.exe)安装就不用说了，上面两个的区别自己去琢磨吧！\n\nMac：terminal : brew install git\n\n\n完成上面的步骤就算安装好环境了，你离git已经很近了，下面是怎么配置。\n12345678#配置全局用户名和邮箱#Linux: shell ，Windows: Git Bash ，Mac:terminal 命令如下：git config --global user.name &quot;yourname&quot;git config --global user.email &quot;Youremail@gmail#查看是否配置成功：git config --global user.namegit config --global user.email","text":"git install and config install Linux: 1shell 界面输入 ``sudo apt-get install git-core`` 回车输入密码 Windows：下载 12345[git-for-windows](https://github.com/git-for-windows/git/releases/tag/v2.6.3.windows.1)[github-windows](https://github-windows.s3.amazonaws.com/GitHubSetup.exe)安装就不用说了，上面两个的区别自己去琢磨吧！ Mac：terminal : brew install git 完成上面的步骤就算安装好环境了，你离git已经很近了，下面是怎么配置。 12345678#配置全局用户名和邮箱#Linux: shell ，Windows: Git Bash ，Mac:terminal 命令如下：git config --global user.name &quot;yourname&quot;git config --global user.email &quot;Youremail@gmail#查看是否配置成功：git config --global user.namegit config --global user.email creat local repository connect remote首先你要在本地创建一个仓库，也就是repository（creat a local repository）：12345#cd 到你要建仓库的文件夹，建的仓库会在该文件夹下生成一个和仓库同名的文件夹#所以你不必自己建立一个和仓库同名的文件夹#假如你的仓库都要放在D:/GitHub/下cd D:/GitHubgit init mygit 就是这么简单仓库就建好了，你会发现在D:/GitHub下生成了一个mygit文件夹，同时文件夹内有一个.git隐藏文件。那么现在D:/GitHub/mygit/就是你的本地仓库了。如果你不想让你的代码发布到网络的话，在这里你完全可以使用git的所有功能。不过我们要做的还是想要他发布到网上，那就是GitHub了。 建立一个远程仓库（creat a remote repository）在git.hub.com创建一个新的仓库，一定要是空的。当然你要先登录你的帐号，如果连账号都搞不定我想你可以Ctrl+W了。当然了你可以百度–。 完成以后你的远程仓库也就建好了。不过你还需要将刚才建立的本地仓库与远程的仓库建立连接。那么你就需要你的远程仓库地址 连接支持HTTPs和SSH两种协议，推荐使用ＳＳＨ连接。 我的连接是&#x67;&#105;&#x74;&#x40;&#103;&#x69;&#116;&#104;&#117;&#98;&#46;&#99;&#111;&#109;&#58;&#121;&#103;&#x63;&#x61;&#x69;&#x63;&#110;&#47;&#x6d;&#121;&#x67;&#105;&#x74;&#46;&#x67;&#x69;&#116;, （这用的是SSH连接地址） 本地仓库与远程仓库连接( connect a remote repository )#打开git shell cd D:/github/mygit git remote add origin git@github.com:ygcaicn/mygit.git Quick setup — if you’ve done this kind of thing before…or create a new repository on the command lineecho &quot;# test&quot; &gt;&gt; README.md git init git add README.md git commit -m &quot;first commit&quot; git remote add origin git@github.com:ygcaicn/test.git git push -u origin master …or push an existing repository from the command line git remote add origin git@github.com:ygcaicn/test.git git push -u origin master …or import code from another repositoryYou can initialize this repository with code from a Subversion, Mercurial, or TFS project. 上面是建立完仓库官方给出的Quick setup. 上传本地仓库 Update建立远程连接更新本地的改动到云端 git add -A git commit -m &quot;first commit&quot; git push -u origin master //由于第一次push加-u 后来的push不需要加-u参数。到此你已经可以简单的使用git了。不过git远不只这么多东西，它没这么简单。 下面介绍一些Github常用的skillcreat remote repository clone to local将代码仓库clone到本地，其实就是将代码复制到你的机器里，并交由Git来管理： git clone git@github.com:ygcaicn/mygit.git git常用的命令:git-scm官方文档关于git-scm是什么和git的区别，请按下Ctrl点击 git add：把要提交的代码添加进来，可以认为到一个缓冲中[重要] 官方文档 提交文件test.c： git add test.c 提交目录test ： git add test 添加删除后的所有文件： git add . 或者： ~~git add -A~~ 添加所有文件（和上面的区别我也不知道） #一定要是大A强调一下，Shell下的所有操作都是区分大小写的 #不过Windows下还有区别，因为~~万恶的Windows~~是不区分文件的大小写的 git add -A 上面的add添加操作相当于把文件写入到了一个仓库的缓存区，但是还没有真正的写入到仓库的磁盘中 git commit本地提交commit：add完成后，真正的代码提交[重要] 官方文档 git commit -m “commit” // -m 描述信息，不能为空 本地提交就是将缓存区的文件改动写入仓库的磁盘。 git status: 查看上次提交后文件修改的列表 git status git diff：查看文件修改的内容，-号代表删除部分，+号代表添加部分 git diff TestB.java // 查看TestB.java修改的内容 checkout：撤销未提交的修改（未执行add操作） git checkout TestB.java // 撤销TestB.java的修改 reset：取消add状态 git reset HEAD TestB.java // 取消TestB.java的add状态 log：查看提交记录（内容包含提交id,提交人，提交日期，描述信息） git log // 所有记录 git log xxxxx(id) -1 // 查看当前id的记录，-1表示一行记录 git log xxxxx(id) -1 -p // 查看当前id提交记录的修改 + `.gitignore`文件: git会检查是否存在该文件，存在就读取该文件内容，将配置文件或者目录排除在版本之外，文件和目录可以使用“\\*”通配符。可以手动创建在文件。 123456789101112131415161718192021222324252627282930313233#Compiled Object files*.slo*.lo*.o*.obj# Precompiled Headers*.gch*.pch# Compiled Dynamic libraries*.so*.dylib*.dll# Fortran module files*.mod# Compiled Static libraries*.lai*.la*.a*.lib# Executables*.exe*.out*.app#Editplus*.bakTestA.c // 排除该文件 testDir // 排除该目录 git 分支分支：可以在现有代码上拉出一个分支，使得代码可以在主干与分支同时开发，并且代码之间互相不会影响。常见使用环境，就是每次版本发布，已发布的可以拉出一个分支，剩下的功能继续在主干开发，如果发布版本有问题，只用修改分支，最终将代码合并到主干。 分支命令： 123456git branch -a // 查看所有分支，master主干，分支前有*号，表示当前处于那个分支git branch release1.0 // 创建release1.0分支，git checkout release1.0 // 切换到release1.0分支，主要与文件修改撤销的区别git checkout master // 1： 切换到主干git merge release1.0 // 2： 将release1.0的修改合并到master，如果有冲突解决冲突git branch -D release1.0 // 删除release1.0分支 远程版本库 比如有远程版本库(仓库)，https://github.com/FreeSunny/RefreashTabView.git git clone https://github.com/FreeSunny/RefreashTabView.git // 下载到本地 远程库命令： pussh：将代码修改和提交同步到远程库 [重要] #origin 指定远程版本库的 Git 地址，master 指定同步到哪一个分支 git push origin master fetch：远程库的修改同步到本地, 不会将代码合并到任何分支，会存放到一个origin/master分支上 #注释同 git fetch origin master diff：查看远程库修改内容 #注意有一个斜线，就是fetch同步后放置的位 git diff origin/master merge：将origin/master分支修改的内容合并到主分支 #注意斜线 git merge origin/master pull：fetch + merge，拉取并且合并[重要] #没有斜线 git pull origin master Git常用速查 gitbub网址知易行难，say easy than do， 下面就来一个小小的实例，必须要有git账号，这个步骤就不用say了吧！ 创建远程库a. 点击+号下的New repository 创建一个远程库，命名为GitOperate, b. 版本库类型可以public或者private，程序员都有开源的心，那就public。 c. 还可以勾选Initialize this repository with a README， d. 接下来可以选择添加.gitignore文件，.gitignore文件有很多类型可以选， 比如 Android，Android项目下的bin这些文件一般都不需要提交。 选择遵循的协议。eg：Apache License 2.0, 这个可以自己去查查每种的意思 e. 点击create，远程版本库就创建完成了，远程版本库的地址为 https://github.com/FreeSunny/GitOperate.git。 之后跳转到README.md,该文件主要是对项目的描述。 远程库克隆到本地a. 本地创建一个GitOperate文件夹 b. 远程库地址为https://github.com/FreeSunny/GitOperate.git， cd进入GitOperate，输入 *git clone https://github.com/FreeSunny/GitOperate.git* c. 完成后可以在GitOperater文件下的GitOperate文件夹下看到README.md文件（两层文件夹了） d. 将第二个目录下的所有文件全部复制到上一层目录中，这样就只有第一层目录添加到版本控制中。 操作命令为(cp -r GitOperate/ .) 提交代码git add .// 将提交的代码添加进来，这里指README.md git commit -m “add readme” // 本地提交 git push origin master // 同步到远程库 Refhtpp://iissnan.com/progit/","raw":null,"content":null,"categories":[{"name":"建站","slug":"建站","permalink":"https://ygcaicn.github.io/categories/建站/"}],"tags":[{"name":"github","slug":"github","permalink":"https://ygcaicn.github.io/tags/github/"}]},{"title":"Hello World","slug":"hello-world","date":"2016-10-13T16:00:00.000Z","updated":"2018-01-15T10:20:49.097Z","comments":true,"path":"杂项/hello-world.html","link":"","permalink":"https://ygcaicn.github.io/杂项/hello-world.html","excerpt":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","raw":null,"content":null,"categories":[{"name":"杂项","slug":"杂项","permalink":"https://ygcaicn.github.io/categories/杂项/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://ygcaicn.github.io/tags/hexo/"}]}]}